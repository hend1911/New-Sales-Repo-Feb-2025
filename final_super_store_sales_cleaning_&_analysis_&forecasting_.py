# -*- coding: utf-8 -*-
"""Final Super Store Sales  Cleaning & Analysis &Forecasting  .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qMo7-F6MHmpiToF9G1yzwx-g3K9UHf9T

##  ***importing***data**
"""

import pandas as pd

# Try reading the file with 'latin-1' encoding
file = pd.read_csv("Superstore Sales Dataset.csv", encoding='latin-1')
# If 'latin-1' doesn't work, try 'cp1252'
# file = pd.read_csv("Superstore Sales Dataset.csv", encoding='cp1252')
file

"""##** EXPLORING DATA**"""

file.head()

file.tail()

file.shape

file.dtypes

file.info()

file.columns

# Assuming 'file' contains your original DataFrame

# Select categorical features (replace with your actual categorical columns)
# The column name was changed from 'Ship Mode' to 'Ship_Mode'
#file_cat = file[['Ship_Mode', 'Segment', 'Country', 'City', 'State', 'Region', 'Category', 'Sub-Category']]
#The above line had the error, It has been corrected to the below
file_cat = file[['Ship Mode', 'Segment', 'Country', 'City', 'State', 'Region', 'Category', 'Sub-Category']] # Replaced 'Ship_Mode' with 'Ship Mode'

# Now you can iterate through the columns of 'file_cat'
for feature in file_cat.columns:
    print(feature,':',file[feature].nunique())

"""## TASK1-**cleaning**

## Check for missing values
"""

file.isnull().sum()

file.isnull().sum().sum()

file.duplicated().sum()

"""## Convert 'Order Date' and 'Ship Date' to datetime"""

file['Order Date'] = pd.to_datetime(file['Order Date'], format='%m/%d/%Y') # Changed format to '%m/%d/%Y'
file['Ship Date'] = pd.to_datetime(file['Ship Date'], format='%m/%d/%Y') # Changed format to '%m/%d/%Y'

file.info()

# Describe salesto check for anomalies
sales_summary = file[['Sales','Quantity','Discount','Profit']].describe() # Changed tuple to list for column selection
sales_summary

"""## التعامل مع القيم الشاذة (Outliers)

"""

import seaborn as sns
sns.boxplot(data=file[['Sales','Quantity','Discount','Profit']])

"""##  استخدام التقسيم أو التجميع (Binning or Bucketing)


"""

bins = [0, 500, 1000, 5000, 10000, 20000]
labels = ['Very Low', 'Low', 'Medium', 'High', 'Very High']
file['Sales_Category'] = pd.cut(file['Sales'], bins=bins, labels=labels) # Changed 'data' to 'file' to refer to the correct DataFrame

file.info()  #added sale catagory to deal with outliers

file.isnull().sum()

import pandas as pd

# Assuming 'file' contains your original DataFrame

# Define bins and labels for 'Sales_Category'
bins = [0, 500, 1000, 5000, 10000, 20000]
labels = ['Very Low', 'Low', 'Medium', 'High', 'Very High']

# Create the 'Sales_Category' column
file['Sales_Category'] = pd.cut(file['Sales'], bins=bins, labels=labels)

# Now you can access the 'Sales_Category' column
most_frequent = file['Sales_Category'].mode()[0]     #استبدال القيم المفقودة بالقيمة الأكثر تكرارًا
file['Sales_Category'].fillna(most_frequent, inplace=True)

file.isnull().sum()

file.rename(columns={'Row ID':'Identity_Key','Order Date': 'order_date', 'Postal Code': 'postal_code','Ship Date':'Ship_Date','Ship Mode':'Ship_Mode'}, inplace=True)
#إعادة تسمية الأعمدة

file.columns

# إضافة عمود الشهر
file['Month'] = file['order_date'].dt.month # Changed 'Order Date' to 'order_date'

# إضافة عمود السنة
file['Year'] = file['order_date'].dt.year # Changed 'Order Date' to 'order_date'

# عرض البيانات للتحقق
print(file[['order_date', 'Month', 'Year']].head()) # Changed 'Order Date' to 'order_date'

# إضافة عمود جديد للربع السنوي باستخدام أسماء الأرباع
file['Quarter'] = file['order_date'].dt.quarter.map({1: 'Q1', 2: 'Q2', 3: 'Q3', 4: 'Q4'})

# عرض أول خمس صفوف للتأكد
print(file[['order_date', 'Month', 'Year','Quarter']].head()) # Changed 'Order Date' to 'order_date' to match the column name

# إضافة عمود نسبة الربح إلى المبيعات (Profit Margin)
file['Profit_Margin'] = (file['Profit'] / file['Sales']) * 100

# إضافة عمود متوسط الخصم لكل طلب
file['Average_Discount_Per_Order'] = file.groupby('Order ID')['Discount'].transform('mean')

# إضافة عمود إجمالي الكمية المباعة لكل طلب
file['Total_Quantity_Per_Order'] = file.groupby('Order ID')['Quantity'].transform('sum')

# حساب نسبة الخصم إلى المبيعات (Discount Percentage)
file['Discount_Percentage'] = (file['Discount'] / file['Sales']) * 100

# إضافة عمود نسبة الربح إلى إجمالي المبيعات (Profit Percentage)
file['Profit_Percentage'] = (file['Profit'] / file['Sales']) * 100

# عرض بعض العينات للتحقق من القيم
print(file[['Sales', 'Profit', 'Discount', 'Profit_Margin', 'Discount_Percentage',
            'Average_Discount_Per_Order', 'Total_Quantity_Per_Order', 'Profit_Percentage']].head())

# توحيد العملات
conversion_rate = 1  # Define the conversion rate here, e.g., 1 for no conversion
file['Sales'] = file['Sales'] * conversion_rate

# حساب الفرق بين التواريخ وإضافته كعمود جديد
file['Shipping Duration'] = (file['Ship_Date'] - file['order_date']).dt.days

file.columns

columns_order = [
    'Identity_Key','Order ID', 'order_date', 'Ship_Date', 'Shipping Duration', 'Ship_Mode',
    'Customer ID', 'Customer Name', 'Segment', 'postal_code', 'Country', 'City', 'State',
    'Region', 'Product ID', 'Product Name', 'Category', 'Sub-Category',
    'Sales', 'Quantity', 'Discount', 'Profit', 'Profit_Margin', 'Discount_Percentage','Profit_Percentage',
    'Average_Discount_Per_Order', 'Total_Quantity_Per_Order', 'Sales_Category', 'Month', 'Year', 'Quarter',
]

# إعادة ترتيب الأعمدة
file = file[columns_order]
#عادة ترتيب الأعمدة لتحسين عرض البيانات

file.columns

file.info()

import os

# Create the directory if it doesn't exist
os.makedirs('/mnt/data', exist_ok=True)

# Now you can save the file
file.to_csv('/mnt/data/Superstore_Sales_with_Quarters.csv', index=False)

from google.colab import files
# Change the filename to match the saved filename
files.download('/mnt/data/Superstore_Sales_with_Quarters.csv')

"""## **modeling**

## CREATING PRIMARY KEYS FOR TABLES
"""

file['LOCATION KEY'] = file['postal_code'].astype(str) + "_" + file['State']
file['PRODUCT KEY'] = file['Product ID'].astype(str) + "_" + file['Product Name']

file.to_csv('Superstore_Sales_with_Keys.csv', index=False) # Assuming you want to save it as "Superstore_Sales_with_Keys.csv"
from google.colab import files

files.download('Superstore_Sales_with_Keys.csv')

file.info()

# إنشاء جداول فرعية

# Orders Table
orders_table = file[[
   'Identity_Key', 'Order ID', 'order_date', 'Ship_Date', 'Shipping Duration', 'Ship_Mode',
    'Month', 'Year', 'Quarter', 'Quantity', 'Sales', 'Profit', 'Discount',
    'Sales_Category', 'Profit_Margin', 'Discount_Percentage', 'Profit_Percentage',
    'Average_Discount_Per_Order', 'Total_Quantity_Per_Order', 'Customer ID','postal_code','Region','City', # Removed the leading space before 'City'
    'LOCATION KEY', 'Product ID','Product Name','PRODUCT KEY'
]].drop_duplicates()

# Customers Table
customers_table = file[[
    'Customer ID', 'Customer Name', 'Segment'
]].drop_duplicates()

# Products Table
products_table = file[[
    'PRODUCT KEY', 'Product ID', 'Product Name', 'Category', 'Sub-Category'
]].drop_duplicates()

# Location Table
location_table = file[[  # Changed to lowercase 'location_table' for consistency
    'LOCATION KEY', 'postal_code', 'Region', 'Country', 'State', 'City'
]].drop_duplicates()

# حفظ الجداول كملفات CSV
orders_table.to_csv('orders_table.csv', index=False)
customers_table.to_csv('customers_table.csv', index=False)
products_table.to_csv('products_table.csv', index=False)
location_table.to_csv('location_table.csv', index=False)  # Changed LOCATION_table to location_tableع

from google.colab import files

# Download each file
files.download('orders_table.csv')
files.download('customers_table.csv')
files.download('products_table.csv')
files.download('location_table.csv')  # Changed 'LOCATION_table.csv' to 'location_table.csv'

print("تم تنزيل الملفات!")


## **2-1 Describtive Overall Finacial Analysis**
"""

#إجماليات الأداء المالي
total_sales = orders_table['Sales'].sum()
total_profit = orders_table['Profit'].sum()
total_discount = orders_table['Discount'].sum()
overall_profit_margin = (total_profit / total_sales) * 100
sales_percentage = (total_sales / total_sales) * 100  # Always 100%
profit_percentage = (total_profit / total_sales) * 100
discount_percentage = (total_discount / total_sales) * 100

print("===== إجماليات الأداء المالي =====")
print(f"Total Sales: ${total_sales:,.2f}")
print(f"Total Profit: ${total_profit:,.2f}")
print(f"Total Discount: ${total_discount:,.2f}")
print(f"Overall Profit Margin: {overall_profit_margin:.2f}%\n")
print(f"Sales Percentage: {sales_percentage:.2f}%")
print(f"Profit Percentage: {profit_percentage:.2f}%")
print(f"Discount Percentage: {discount_percentage:.2f}%\n")

import pandas as pd

# قراءة جدول الطلبات
# Corrected file path to 'orders_table.csv'
orders_table = pd.read_csv('orders_table.csv')  # تأكدي من المسار

# تحديد الأعمدة ذات العلاقة بالتحليل المالي
columns_to_analyze = ['Quantity','Sales', 'Profit', 'Discount', 'Profit_Percentage', 'Profit_Margin',
                      'Discount_Percentage','Average_Discount_Per_Order',
                      'Total_Quantity_Per_Order']  #Fixed typos and extra spaces, separated concatenated columns


# حساب وصف إحصائي مفصل
financial_analysis = orders_table[columns_to_analyze].describe()

# تلوين القيم السالبة باللون الأحمر
def highlight_negative(s):
    '''
    تلوين القيم السالبة باللون الأحمر
    '''
    is_negative = s < 0  # تحديد القيم السالبة فقط
    return ['background-color: red' if v else '' for v in is_negative]  # تطبيق التنسيق

# تطبيق التلوين على الجدول
styled_financial_analysis = financial_analysis.style.apply(highlight_negative)

# عرض النتائج الملونة
display(styled_financial_analysis)

import seaborn as sns
sns.histplot(x=orders_table['Sales'], bins=30, kde=True)

import seaborn as sns
sns.histplot(x=orders_table['Quantity'], bins=30, kde=True)

import seaborn as sns
sns.histplot(x=orders_table['Discount'], bins=30, kde=True)

import seaborn as sns
sns.histplot(x=orders_table['Profit'], bins=30, kde=True)

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# قراءة جدول الطلبات
# Corrected file path to 'orders_table.csv'
orders_table = pd.read_csv('orders_table.csv')  # تأكد من صحة مسار الملف

# رسم تحليل العلاقة بين الخصومات والأرباح
plt.figure(figsize=(8, 6))
sns.scatterplot(x='Discount', y='Profit', data=orders_table, color='blue')
plt.title('Discount vs. Profit', fontsize=14)
plt.xlabel('Discount', fontsize=12)
plt.ylabel('Profit', fontsize=12)
plt.grid(True)
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'orders_table' was created and saved as 'orders_table.csv' earlier
orders_table = pd.read_csv('orders_table.csv')  # Read from the saved CSV file

# تحديد الأعمدة المالية للتحليل
financial_columns = ['Sales', 'Profit', 'Quantity', 'Discount']

# إنشاء مصفوفة الترابط
correlation_matrix = orders_table[financial_columns].corr()

# رسم Heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Correlation Matrix for Financial Metrics')
plt.show()

"""## **(Marketing Performance Analysis)**

"""

#bins = [0, 500, 1000, 5000, 10000, 20000]
#labels = ['Very Low', 'Low', 'Medium', 'High', 'Very High']
#إجمالي المبيعات والأرباح حسب الفئة
category_analysis = orders_table.groupby('Sales_Category').agg({ # Changed 'Sales-Category' to 'Sales_Category'
    'Sales': 'sum',
    'Profit': 'sum',
    'Discount': 'mean'  # Calculate average discount
}).reset_index()

print(category_analysis)

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Assuming you have already calculated 'category_analysis' with the corrected column name
# And you want to include 'Discount' in the visualization

# Calculate average discount for each sales category
category_analysis = orders_table.groupby('Sales_Category').agg({
    'Sales': 'sum',
    'Profit': 'sum',
    'Discount': 'mean'  # Calculate average discount
}).reset_index()

# Set the style for the plot
sns.set_theme(style="whitegrid")

# Create the combo chart
fig, ax1 = plt.subplots(figsize=(12, 6))  # Increased figure size for better readability

# Bar chart for Total Sales and Total Profit
bar_width = 0.35  # Adjust bar width for better spacing
x_pos = np.arange(len(category_analysis['Sales_Category']))

ax1.bar(x_pos, category_analysis['Sales'], width=bar_width, label='Total Sales', color='skyblue')
ax1.bar(x_pos + bar_width, category_analysis['Profit'], width=bar_width, label='Total Profit', color='lightcoral')

# Customize primary y-axis (for Sales and Profit)
ax1.set_ylabel('Amount', fontsize=14)
ax1.set_xlabel('Sales Category', fontsize=14)
ax1.set_title('Sales, Profit, and Discount by Sales Category', fontsize=16, fontweight='bold')
ax1.set_xticks(x_pos + bar_width / 2)  # Center x-axis ticks between bars
ax1.set_xticklabels(category_analysis['Sales_Category'], rotation=45, ha='right', fontsize=12)
ax1.legend(loc='upper left', fontsize=12)

# Secondary y-axis for Average Discount (line chart)
ax2 = ax1.twinx()
ax2.plot(x_pos + bar_width / 2, category_analysis['Discount'], marker='o', color='darkgreen', label='Average Discount')  # Added line for discount
ax2.set_ylabel('Average Discount', fontsize=14)
ax2.legend(loc='upper right', fontsize=12)

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

# إنشاء مجموعة لتجميع الخصومات مع متوسط الأرباح
discount_profit_analysis = orders_table.groupby('Discount')['Profit'].mean().reset_index()

# عرض البيانات
print(discount_profit_analysis)

# فلترة الخصومات التي تؤدي إلى أرباح سلبية
loss_discounts = discount_profit_analysis[discount_profit_analysis['Profit'] < 0]
print(loss_discounts)

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(12, 6))

# رسم الخط مع تحسينات
sns.lineplot(data=discount_profit_analysis, x='Discount', y='Profit', marker='o', color='blue', linestyle='--', linewidth=2)

# إبراز نقاط حرجة (مثال)
plt.axvline(x=0.2, color='gray', linestyle='--') # خط رأسي عند خصم 20%
plt.axhline(y=0, color='red', linestyle='-') # خط أفقي عند ربح 0

# إضافة تسميات لنقاط (مثال)
for x, y in zip(discount_profit_analysis['Discount'], discount_profit_analysis['Profit']):
    if x in [0.1, 0.2, 0.3]:  # نقاط محددة
        plt.text(x, y, f'({x:.1f}, {y:.2f})', ha='center', va='bottom', fontsize=10)

# تحسينات أخرى
plt.title('Effect of Discount on Profit', fontsize=16, fontweight='bold')
plt.xlabel('Discount (%)', fontsize=12)
plt.ylabel('Average Profit', fontsize=12)
plt.grid(True, linestyle='-', alpha=0.5) # شبكة أكثر وضوحًا
plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
sns.scatterplot(x='Discount', y='Sales', hue='Profit', data=orders_table, palette='viridis', s=50)
plt.title('Relationship between Discount, Sales, and Profit')
plt.xlabel('Discount (%)')
plt.ylabel('Sales')
plt.show()

"""## **  بتحليل الاتجاهات الزمنية (Time Trends)**

## **overall analysis for Time**
"""

##لرسم سيوضح أي الشهور تتفوق في الأداء مقارنة بباقي الشهور.
##ستظهر الأعمدة البرتقالية (نسبة التغير) مدى ثبات أو تذبذب المبيعات بين الشهور.

import matplotlib.pyplot as plt
import pandas as pd

# Assuming 'orders_table' contains your data
# Create the 'sales_trend' DataFrame by grouping and aggregating sales by year and month
sales_trend = orders_table.groupby(['Year', 'Month'])['Sales'].sum().reset_index()
sales_trend['Year-Month'] = sales_trend['Year'].astype(str) + '-' + sales_trend['Month'].astype(str).str.zfill(2)  # Create 'Year-Month' column

# Now you can proceed with the rest of your code:
# تحويل 'Year-Month' إلى نوع بيانات datetime
sales_trend['Year-Month'] = pd.to_datetime(sales_trend['Year-Month'], format='%Y-%m')

# تقسيم البيانات حسب السنة
for year in sales_trend['Year'].unique():
    yearly_data = sales_trend[sales_trend['Year'] == year]
    plt.plot(yearly_data['Year-Month'], yearly_data['Sales'], label=year)

# تعيين تنسيق المحور X لعرض الشهور فقط
plt.gca().xaxis.set_major_formatter(plt.matplotlib.dates.DateFormatter('%b'))
plt.gcf().autofmt_xdate()  # تحسين دوران التسميات

plt.legend()
plt.show()

"""## **over years**"""

# تجميع البيانات حسب السنوات
yearly_analysis = orders_table.groupby('Year').agg({
    'Sales': 'sum',
    'Profit': 'sum',
    'Discount': 'mean'
}).reset_index()

# عرض البيانات المجمعة
print(yearly_analysis)

plt.figure(figsize=(14, 8))

# رسم المبيعات
sns.lineplot(data=yearly_analysis, x='Year', y='Sales', label='Sales', marker='o', color='blue')

# رسم الأرباح
sns.lineplot(data=yearly_analysis, x='Year', y='Profit', label='Profit', marker='o', color='green')

# رسم الخصومات
sns.lineplot(data=yearly_analysis, x='Year', y='Discount', label='Discount', marker='o', color='red')

# تحسينات الرسم
plt.title('Sales, Profit, and Discount Trends Over Years', fontsize=16)
plt.xlabel('Year', fontsize=12)
plt.ylabel('Value', fontsize=12)
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# إضافة أعمدة جديدة للنسب المئوية
yearly_analysis['Profit_to_Sales (%)'] = (yearly_analysis['Profit'] / yearly_analysis['Sales']) * 100
yearly_analysis['Discount_to_Sales (%)'] = yearly_analysis['Discount'] * 100

# عرض البيانات مع النسب
print(yearly_analysis)

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(14, 8))

# رسم نسبة الأرباح إلى المبيعات مع تحسينات
sns.lineplot(data=yearly_analysis, x='Year', y='Profit_to_Sales (%)',
             label='Profit to Sales (%)', marker='o', color='#008080', linewidth=2.5)  # Teal color, thicker line

# رسم نسبة الخصومات إلى المبيعات مع تحسينات
sns.lineplot(data=yearly_analysis, x='Year', y='Discount_to_Sales (%)',
             label='Discount to Sales (%)', marker='s', color='#FFA07A', linewidth=2.5, linestyle='--')  # Light Salmon, thicker dashed line

# إضافة تسميات لنقاط البيانات
for x, y in zip(yearly_analysis['Year'], yearly_analysis['Profit_to_Sales (%)']):
    plt.text(x, y, f'{y:.2f}%', ha='center', va='bottom', fontsize=10)  # Profit labels

for x, y in zip(yearly_analysis['Year'], yearly_analysis['Discount_to_Sales (%)']):
    plt.text(x, y, f'{y:.2f}%', ha='center', va='top', fontsize=10)  # Discount labels


# تحسينات الرسم
plt.title('Profit and Discount Percentage Relative to Sales (Over Years)', fontsize=16, fontweight='bold')
plt.xlabel('Year', fontsize=14)
plt.ylabel('Percentage (%)', fontsize=14)
plt.legend(fontsize=12)
plt.grid(True, linestyle='--', alpha=0.7)  # Lighter grid
sns.despine()  # Remove top and right spines
plt.tight_layout()
plt.show()

"""## **Over Quarter**"""

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# تجميع البيانات حسب الربع
quarterly_analysis = orders_table.groupby('Quarter').agg({
    'Sales': 'sum',
    'Profit': 'sum',
    'Discount': 'mean'
}).reset_index()

# رسم العلاقة بين الأرباح والمبيعات لكل ربع مع تحسينات
plt.figure(figsize=(12, 6))

# Use a clustered bar chart for better comparison
width = 0.35  # Width of each bar
x = np.arange(len(quarterly_analysis['Quarter']))

# Plot Sales and Profit side-by-side
plt.bar(x - width/2, quarterly_analysis['Sales'], width, label='Sales', color='skyblue')
plt.bar(x + width/2, quarterly_analysis['Profit'], width, label='Profit', color='lightcoral')

# Add data labels for better clarity
for i, v in enumerate(quarterly_analysis['Sales']):
    plt.text(i - width/2, v + 500, str(int(v)), ha='center', color='black', fontsize=10)  # Sales labels
for i, v in enumerate(quarterly_analysis['Profit']):
    plt.text(i + width/2, v + 500, str(int(v)), ha='center', color='black', fontsize=10)  # Profit labels

# Customize the plot
plt.title('Quarterly Sales and Profit Analysis', fontsize=16, fontweight='bold')
plt.xlabel('Quarter', fontsize=14)
plt.ylabel('Value', fontsize=14)
plt.xticks(x, quarterly_analysis['Quarter'], fontsize=12)
plt.yticks(fontsize=12)
plt.legend(fontsize=12)
plt.grid(True, linestyle='--', alpha=0.7)  # Lighter grid
sns.despine()  # Remove top and right spines for a cleaner look
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Assuming 'quarterly_analysis' is already calculated

# رسم تأثير الخصومات على الأرباح لكل ربع مع تحسينات
plt.figure(figsize=(12, 6))

# Use a more distinct color palette
sns.scatterplot(
    data=quarterly_analysis,
    x='Discount',
    y='Profit',
    hue='Quarter',
    palette='Set1',  # Use a colorblind-friendly palette
    s=100,
    alpha=0.7,  # Add transparency for better readability
    edgecolor='black',  # Add edge color to the markers
    linewidth=1.2,  # Adjust linewidth for better visibility
)

# Customize the plot
plt.title('Discount vs Profit per Quarter', fontsize=16, fontweight='bold')
plt.xlabel('Average Discount', fontsize=14)
plt.ylabel('Total Profit', fontsize=14)
plt.grid(True, linestyle='--', alpha=0.7)  # Lighter grid
sns.despine()  # Remove top and right spines for a cleaner look
plt.legend(fontsize=12, title='Quarter', title_fontsize=12)  # Customize legend

plt.tight_layout()
plt.show()

sales_by_quarter = orders_table.groupby('Quarter')['Sales'].sum()
print(sales_by_quarter)

"""## **over Month**"""

# حساب إجمالي المبيعات لكل شهر عبر جميع السنوات
monthly_avg_sales = orders_table.groupby('Month')['Sales'].mean().reset_index()

# ترتيب الشهور
monthly_avg_sales = monthly_avg_sales.sort_values('Month')

# عرض البيانات
print(monthly_avg_sales)

import matplotlib.pyplot as plt
import seaborn as sns

# Assuming you have already calculated 'monthly_avg_sales'

# Set the style for the plot
sns.set_theme(style="whitegrid")

# Create the bar plot
plt.figure(figsize=(12, 6))
ax = sns.barplot(x='Month', y='Sales', data=monthly_avg_sales, palette='viridis')

# Customize the plot
plt.title('Average Monthly Sales Across All Years', fontsize=16, fontweight='bold')
plt.xlabel('Month', fontsize=14)
plt.ylabel('Average Sales', fontsize=14)
plt.xticks(rotation=45, ha='right', fontsize=12)

# Add labels to the bars
for p in ax.patches:
    ax.annotate(f'{p.get_height():.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center', xytext=(0, 10), textcoords='offset points', fontsize=10)

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

# إضافة عمود لنسبة التغير
monthly_avg_sales['Percentage Change'] = monthly_avg_sales['Sales'].pct_change() * 100

# عرض البيانات
print(monthly_avg_sales)

# تجميع البيانات حسب الشهر
monthly_analysis = orders_table.groupby('Month').agg({'Profit': 'sum', 'Discount': 'mean'}).reset_index()

# عرض البيانات
print(monthly_analysis)

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(14, 7))

# خط المبيعات الشهرية
plt.plot(monthly_avg_sales['Month'], monthly_avg_sales['Sales'], marker='o', label='Monthly Avg Sales', color='darkblue', linewidth=2)

# إضافة تسميات لقيم المبيعات
for x, y in zip(monthly_avg_sales['Month'], monthly_avg_sales['Sales']):
    plt.text(x, y, f'{y:.2f}', ha='center', va='bottom', fontsize=10)

# نسبة التغيير
plt.bar(monthly_avg_sales['Month'], monthly_avg_sales['Percentage Change'], alpha=0.5, color='lightcoral', label='Percentage Change')

# تحسينات التنسيق
plt.title('Monthly Sales Trends and Percentage Change', fontsize=18, fontweight='bold')
plt.xlabel('Month', fontsize=14)
plt.ylabel('Sales / Percentage Change', fontsize=14)
plt.xticks(monthly_avg_sales['Month'], rotation=45, fontsize=12)
plt.yticks(fontsize=12)
plt.legend(fontsize=12)
plt.grid(True, linestyle='--', alpha=0.7)
sns.despine() # Remove the top and right spines
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Calculate average discount for each month
monthly_analysis = orders_table.groupby('Month').agg({
    'Profit': 'sum',
    'Discount': 'mean'  # Calculate average discount
}).reset_index()

# Set the style for the plot
sns.set_theme(style="whitegrid")

# Create the combo chart
fig, ax1 = plt.subplots(figsize=(12, 6))  # Increased figure size for better readability

# Bar chart for Discount
bar_width = 0.35  # Adjust bar width for better spacing
x_pos = np.arange(len(monthly_analysis['Month']))
ax1.bar(x_pos, monthly_analysis['Discount'], width=bar_width, label='Discount', color='red')

# Customize primary y-axis (for Discount)
ax1.set_ylabel('Average Discount', fontsize=14)
ax1.set_xlabel('Month', fontsize=14)
ax1.set_title('Profit and Discount Trends Over Months', fontsize=16, fontweight='bold')
ax1.set_xticks(x_pos)  # Set x-axis ticks for each month
ax1.set_xticklabels(monthly_analysis['Month'], rotation=45, ha='right', fontsize=12)  # Rotate x-axis labels

# Secondary y-axis for Profit (line chart)
ax2 = ax1.twinx()
ax2.plot(x_pos, monthly_analysis['Profit'], marker='o', color='green', label='Profit')  # Plot profit line
ax2.set_ylabel('Total Profit', fontsize=14)

# Add legend
lines, labels = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax2.legend(lines + lines2, labels + labels2, loc='upper left', fontsize=12)  # Combine legends

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

#  تجميع البيانات وحساب المبيعات اليومية لكل شهر, discount, profit
# Convert 'order_date' to datetime if it's not already
orders_table['order_date'] = pd.to_datetime(orders_table['order_date'])
daily_sales_by_month = orders_table.groupby(['Month', orders_table['order_date'].dt.day]).agg(
    {'Sales': 'sum', 'Discount': 'mean', 'Profit': 'sum'}  # Include Discount and Profit
).reset_index()

#  إعادة تسمية الأعمدة
daily_sales_by_month.columns = ['Month', 'Day', 'Sales', 'Average Discount', 'Total Profit']

#  إيجاد اليوم ذو أعلى مبيعات لكل شهر
top_sales_days = daily_sales_by_month.loc[daily_sales_by_month.groupby('Month')['Sales'].idxmax()]

# 6. عرض النتائج مع تلوين profit سالب باللون الأحمر
def highlight_negative_profit(s):
    '''
    تلوين القيم السالبة في عمود 'Total Profit' باللون الأحمر
    '''
    is_negative = s < 0
    return ['color: red' if v else '' for v in is_negative]

styled_top_sales_days = top_sales_days.style.apply(highlight_negative_profit, axis=0, subset=['Total Profit'])
display(styled_top_sales_days)  # Use display for styled output in Jupyter Notebook

"""## focus on march

"""

average_discount_march = orders_table[orders_table['Month'] == 3]['Discount'].mean()
average_discount_other_months = orders_table[orders_table['Month'] != 3]['Discount'].mean()
print(average_discount_march)
print(average_discount_other_months)

daily_sales_march = orders_table[orders_table['Month'] == 3].groupby('order_date')['Sales'].sum() # Changed 'Order Date' to 'order_date'
print(daily_sales_march)

# 3. تجميع البيانات وحساب المبيعات اليومية لكل شهر, discount, profit
# Convert 'order_date' to datetime if it's not already
orders_table['order_date'] = pd.to_datetime(orders_table['order_date'])

# Filter data for March (Month 3)
march_data = orders_table[orders_table['Month'] == 3]

daily_sales_march = march_data.groupby(march_data['order_date'].dt.day).agg(
    {'Sales': 'sum', 'Discount': 'mean', 'Profit': 'sum'}  # Include Discount and Profit
).reset_index()


# 4. إعادة تسمية الأعمدة
daily_sales_march.columns = ['Day', 'Sales', 'Average Discount', 'Total Profit']

# 5. إيجاد اليوم ذو أعلى مبيعات لكل شهر
top_sales_days_march = daily_sales_march.loc[daily_sales_march['Sales'].idxmax()] # Find the day with maximum sales

# Convert the Series to a DataFrame with a single row before styling:
top_sales_days_march = top_sales_days_march.to_frame().T  # Transpose to have columns

# 6. عرض النتائج مع تلوين profit سالب باللون الأحمر
def highlight_negative_profit(s):
    '''
    تلوين القيم السالبة في عمود 'Total Profit' باللون الأحمر
    '''
    is_negative = s < 0
    return ['color: red' if v else '' for v in is_negative]

styled_top_sales_days_march = top_sales_days_march.style.apply(highlight_negative_profit, axis=0, subset=['Total Profit']) # Convert to DataFrame for styling
display(styled_top_sales_days_march)  # Use display for styled output in Jupyter Notebook

"""## **تحليل جدول العملاء (customers_table)**


"""

# 1. Total number of customers
total_customers = customers_table['Customer ID'].nunique()
print(f"Total number of customers: {total_customers}")

# 2. Distribution of customers by segments
segment_distribution = customers_table['Segment'].value_counts()
print("\nCustomer distribution by segments:")
print(segment_distribution)

# Bar chart for customer segments with enhancements
import matplotlib.pyplot as plt
import seaborn as sns  # Import seaborn

# Apply the seaborn style before creating the plot
sns.set_theme(style="darkgrid")  # Use seaborn.set_theme to set the style

ax = segment_distribution.plot(kind='bar', color=sns.color_palette("viridis", n_colors=segment_distribution.shape[0]), figsize=(8, 5))

# Adding title and axis labels
plt.title('Customer Distribution by Segment', fontsize=14, fontweight='bold')
plt.xlabel('Segment', fontsize=12)
plt.ylabel('Number of Customers', fontsize=12)

# Adding numbers above the bars
for i, v in enumerate(segment_distribution):
    plt.text(i, v + 1, str(v), ha='center', fontsize=10)

plt.xticks(rotation=0)  # Keep segment labels horizontal
plt.tight_layout()  # Adjust layout
plt.show()

#  Linking customers to orders
customer_orders = orders_table.groupby('Customer ID')['Order ID'].nunique().reset_index()
customer_orders.columns = ['Customer ID', 'Total Orders']
print(customer_orders.head())


# Calculate the average number of orders per customer
avg_orders_per_customer = customer_orders['Total Orders'].mean()
print(f"\nAverage number of orders per customer: {avg_orders_per_customer:.2f}")

# ربط العملاء مع الطلبات
customer_orders = orders_table.merge(customers_table, on='Customer ID', how='inner')

# Get the 'postal_code' for each 'Customer ID' to link with regions_table
# Instead of trying to get 'postal_code' from customer_orders, get it from the original 'file' DataFrame
customer_postal_codes = file[['Customer ID', 'postal_code']].drop_duplicates().groupby('Customer ID')['postal_code'].first().reset_index()

# تلخيص الأداء العام لكل عميل
customer_performance = customer_orders.groupby('Customer ID').agg({
    'Order ID': 'nunique',  # عدد الطلبات الفريدة لكل عميل
}).reset_index()
customer_performance.rename(columns={'Order ID': 'Total Orders'}, inplace=True)

# Merge with customer_postal_codes to add 'postal_code'
customer_performance = customer_performance.merge(customer_postal_codes, on='Customer ID', how='left')

# Merge with location_table to get 'Region' based on 'postal_code', changed regions_table to location_table
customer_performance = customer_performance.merge(location_table[['postal_code', 'Region']], on='postal_code', how='left')


# حساب الأداء المالي لكل عميل من جدول الطلبات مباشرة
customer_financial_performance = orders_table.groupby('Customer ID').agg({
    'Sales': 'sum',         # إجمالي المبيعات لكل عميل
    'Profit': 'sum',        # إجمالي الأرباح لكل عميل
    'Discount': 'sum',      # إجمالي الخصومات لكل عميل
}).reset_index()

# دمج الأداء المالي مع الأداء العام
final_customer_performance = customer_performance.merge(customer_financial_performance, on='Customer ID', how='inner')

# إضافة معلومات القطاع (Segment)
final_customer_performance = final_customer_performance.merge(customers_table[['Customer ID', 'Segment']], on='Customer ID', how='inner')

# عرض البيانات النهائية
print(final_customer_performance.head())

#توزيع المبيعات حسب القطاعات
import matplotlib.pyplot as plt
import seaborn as sns

# Calculate total sales by segment
segment_sales = final_customer_performance.groupby('Segment')['Sales'].sum().reset_index()

# Set the style for the plot
sns.set_theme(style="whitegrid")  # Use a clean whitegrid style

# Create the bar plot with enhanced styling
plt.figure(figsize=(10, 6))  # Adjust figure size for better proportions
ax = sns.barplot(
    data=segment_sales,
    x='Segment',
    y='Sales',
    palette="viridis",  # Choose a visually appealing color palette
    edgecolor=".2",  # Add edge color to the bars
    linewidth=1.5,  # Adjust linewidth for better visibility
)

# Customize the plot elements
plt.title(
    'Total Sales by Customer Segment',  # Add a clear and concise title
    fontsize=16,  # Adjust font size for emphasis
    fontweight='bold',  # Make the title bold
)
plt.xlabel(
    'Customer Segment',  # Use a descriptive x-axis label
    fontsize=14,  # Adjust font size for readability
)
plt.ylabel(
    'Total Sales',  # Use a descriptive y-axis label
    fontsize=14,  # Adjust font size for readability
)

# Add data labels to the bars
for p in ax.patches:
    ax.annotate(
        f'{p.get_height():.0f}',  # Format the data label (e.g., remove decimals)
        (p.get_x() + p.get_width() / 2., p.get_height()),  # Position the label
        ha='center',  # Horizontal alignment
        va='center',  # Vertical alignment
        xytext=(0, 10),  # Adjust label offset
        textcoords='offset points',  # Use offset points for positioning
        fontsize=12,  # Adjust font size
    )

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Calculate total sales, profit, and average discount by segment
segment_performance = final_customer_performance.groupby('Segment').agg(
    Total_Sales=('Sales', 'sum'),
    Total_Profit=('Profit', 'sum'),
    Average_Discount=('Discount', 'mean')  # Calculate average discount
).reset_index()

# Set the style for the plot
sns.set_theme(style="whitegrid")

# Create the combo chart
fig, ax1 = plt.subplots(figsize=(12, 6))

# Bar chart for Total Sales and Total Profit
bar_width = 0.35  # Adjust bar width and line position # This was the problematic comment, changed to regular comment
x_pos = np.arange(len(segment_performance['Segment']))

ax1.bar(x_pos, segment_performance['Total_Sales'], width=bar_width, label='Total Sales', color='skyblue')
ax1.bar(x_pos + bar_width, segment_performance['Total_Profit'], width=bar_width, label='Total Profit', color='lightcoral')

# Customize primary y-axis (for Sales and Profit)
ax1.set_ylabel('Amount', fontsize=14)
ax1.set_xlabel('Customer Segment', fontsize=14)
ax1.set_title('Sales, Profit, and Discount by Customer Segment', fontsize=16, fontweight='bold')
ax1.set_xticks(x_pos + bar_width / 2)
ax1.set_xticklabels(segment_performance['Segment'], rotation=45, ha='right', fontsize=12)
ax1.legend(loc='upper left', fontsize=12)

# Secondary y-axis for Average Discount (line chart)
ax2 = ax1.twinx()
ax2.plot(x_pos + bar_width / 2, segment_performance['Average_Discount'], marker='o', color='darkgreen', label='Average Discount')
ax2.set_ylabel('Average Discount', fontsize=14)
ax2.legend(loc='upper right', fontsize=12)

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

#أفضل 10 عملاء من حيث المبيعات
import matplotlib.pyplot as plt
import seaborn as sns

top_customers = final_customer_performance.nlargest(10, 'Sales')

# Set the style for the plot
sns.set_theme(style="whitegrid")

# Create the bar plot with enhancements
plt.figure(figsize=(12, 6))  # Adjust figure size for better readability
ax = sns.barplot(
    data=top_customers,
    x='Customer ID',
    y='Sales',
    palette='viridis',  # Use a visually appealing color palette
    edgecolor=".2",  # Add edge color to the bars
    linewidth=1.5,  # Adjust linewidth for better visibility
)

# Customize plot elements
plt.title(
    'Top 10 Customers by Sales',
    fontsize=16,
    fontweight='bold',
)
plt.xlabel(
    'Customer ID',
    fontsize=14,
)
plt.ylabel(
    'Total Sales',
    fontsize=14,
)
plt.xticks(rotation=45, ha='right', fontsize=12)  # Rotate x-axis labels for better readability

# Add data labels to the bars
for p in ax.patches:
    ax.annotate(
        f'{p.get_height():.0f}',
        (p.get_x() + p.get_width() / 2., p.get_height()),
        ha='center',
        va='center',
        xytext=(0, 10),
        textcoords='offset points',
        fontsize=10,
    )

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

# Get the top 10 customers by sales
top_customers = final_customer_performance.nlargest(10, 'Sales')['Customer ID'].tolist()

# Link customer IDs with their cities and states using orders_table and regions_table
# Instead of using 'postal_code', use 'LOCATION KEY' which should be present in orders_table
top_customer_locations = orders_table[orders_table['Customer ID'].isin(top_customers)][['Customer ID', 'LOCATION KEY']].drop_duplicates()
top_customer_locations = top_customer_locations.merge(location_table[['LOCATION KEY', 'City', 'State']], on='LOCATION KEY', how='left')  # Use location_table instead of LOCATION_table and regions_table

# Group by Customer ID and get the city and state for each
top_customer_locations = top_customer_locations.groupby('Customer ID')[['City', 'State']].first().reset_index()

# Merge with customers_table to add 'Segment'
top_customer_locations = top_customer_locations.merge(customers_table[['Customer ID', 'Segment']], on='Customer ID', how='left')

# Print the results
print("City, State, and Segment of Top 10 Customers by Sales:")
print(top_customer_locations)

"""## ***Product Analysis ***"""

#دمج البيانات
import pandas as pd

# تحميل البيانات
# Assuming 'orders_table' and 'products_table' are your DataFrames
# If you saved them as CSV files, load them like this:
# orders = pd.read_csv("orders_table.csv")
# products = pd.read_csv("products_table.csv")

orders = orders_table # Assign the orders_table DataFrame to the variable 'orders'
products = products_table # Assign the products_table DataFrame to the variable 'products'

# ربط البيانات باستخدام Product Key
merged_data = orders.merge(products, on="PRODUCT KEY", how="left") # Changed 'Product Key' to 'PRODUCT KEY' to match column name

# عرض أول 5 صفوف بعد الدمج للتأكد
merged_data.head()

"""##** Product Analysis**"""

import pandas as pd

# Assuming 'products_table' is your DataFrame
# If you loaded it from a CSV, use: products_table = pd.read_csv("products_table.csv")

# 1. Total number of products
total_products = products_table.shape[0]  # shape[0] gives the number of rows

# 2. Number of categories
num_categories = products_table['Category'].nunique()

# 3. Number of sub-categories
num_sub_categories = products_table['Sub-Category'].nunique()

# Print the results
print("Total Products:", total_products)
print("Number of Categories:", num_categories)
print("Number of Sub-Categories:", num_sub_categories)

# To see the unique values in Category and Sub-Category columns:
print("\nUnique Categories:", products_table['Category'].unique())
print("\nUnique Sub-Categories:", products_table['Sub-Category'].unique())

orders_table['Product Name'] = orders_table['Product Name'].astype(str)
missing_products = orders_table['Product Name'].isnull().sum()
print(f"عدد القيم المفقودة في Product Name: {missing_products}")
orders_table['Product Name'] = orders_table['Product Name'].str.strip()
duplicate_products = orders_table['Product Name'].duplicated().sum()
print(f"عدد المنتجات المكررة: {duplicate_products}")
print(f"عدد المنتجات الفريدة: {orders_table['Product Name'].nunique()}")
merged_data = orders_table.merge(products_table, on='PRODUCT KEY', how='left') # Corrected variable names and column name
print(merged_data.columns)
# Access the 'Product Name' column from the correct DataFrame (products_table)
# after the merge using the '_y' suffix (since 'how' is 'left')
missing_products = merged_data['Product Name_y'].isnull().sum()
print(f"عدد المنتجات غير المرتبطة بمفتاح في product_table: {missing_products}")

top_10_summary = (
    merged_data.groupby('Product Name_y')
    .agg({'Sales': 'sum', 'Discount': 'mean', 'Profit': 'sum'})
    .nlargest(10, 'Sales')
    .reset_index()
)
import pandas as pd

# تنسيق الجدول بشكل أفضل
from IPython.display import display

display(top_10_summary)

import matplotlib.pyplot as plt
import seaborn as sns

# Assuming 'top_10_summary' is already calculated

# Set the style for the plot
sns.set_theme(style="whitegrid")  # Use a clean whitegrid style

# Create the bar plot with enhancements
plt.figure(figsize=(12, 6))  # Adjust figure size for better readability
ax = sns.barplot(
    data=top_10_summary,
    x='Sales',
    y='Product Name_y',  # Changed 'Product Name_x' to 'Product Name_y'
    palette='viridis',  # Use a visually appealing color palette
    edgecolor=".2",  # Add edge color to the bars
    linewidth=1.5,  # Adjust linewidth for better visibility
)

# Customize plot elements
plt.title(
    'Top 10 Products by Sales',
    fontsize=16,
    fontweight='bold',
)
plt.xlabel(
    'Total Sales',
    fontsize=14,
)
plt.ylabel(
    'Product Name',
    fontsize=14,
)

# Add data labels to the bars
for p in ax.patches:
    ax.annotate(
        f'{p.get_width():.0f}',  # Format the data label (e.g., remove decimals)
        (p.get_width(), p.get_y() + p.get_height() / 2.),  # Position the label
        ha='left',  # Horizontal alignment
        va='center',  # Vertical alignment
        xytext=(5, 0),  # Adjust label offset
        textcoords='offset points',  # Use offset points for positioning
        fontsize=10,  # Adjust font size
    )

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Calculate total sales per product
product_sales = merged_data.groupby('Product Name_y')['Sales'].sum().reset_index()

# Sort products by sales in ascending order
bottom_10_products = product_sales.nsmallest(10, 'Sales')

# Create a bar chart with enhancements
plt.figure(figsize=(12, 6))  # Adjust figure size for better readability
ax = sns.barplot(
    data=bottom_10_products,
    x='Sales',
    y='Product Name_y',
    palette='viridis',  # Use a visually appealing color palette
    edgecolor=".2",  # Add edge color to the bars
    linewidth=1.5,  # Adjust linewidth for better visibility
)

# Customize plot elements
plt.title(
    'Bottom 10 Selling Products',  # Title in English
    fontsize=16,
    fontweight='bold',
)
plt.xlabel(
    'Total Sales',  # X-axis label in English
    fontsize=14,
)
plt.ylabel(
    'Product Name',  # Y-axis label in English
    fontsize=14,
)

# Add data labels to the bars for better readability
for p in ax.patches:
    ax.annotate(
        f'{p.get_width():.0f}',  # Format the data label (e.g., remove decimals)
        (p.get_width(), p.get_y() + p.get_height() / 2.),  # Position the label
        ha='left',  # Horizontal alignment
        va='center',  # Vertical alignment
        xytext=(5, 0),  # Adjust label offset
        textcoords='offset points',  # Use offset points for positioning
        fontsize=10,  # Adjust font size
    )

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

"""##  **Impact discount on profit for products**

"""

# Change the groupby column to 'Product Name_x' or 'Product Name_y',
# depending on the actual column name in 'merged_data'.
product_discount_analysis = merged_data.groupby("Product Name_x").agg({ # Changed to 'Product Name_x'
    "Sales": "sum",
    "Profit": "sum",
    "Discount": "mean" # متوسط الخصم لكل منتج
}).reset_index()

# رسم العلاقة بين الخصم والمبيعات مع تحسينات
plt.figure(figsize=(12, 8))  # Increased figure size for better readability
sns.scatterplot(
    data=product_discount_analysis,
    x="Discount",
    y="Sales",
    hue="Profit",  # Add color based on profit
    size="Profit",  # Vary marker size based on profit
    sizes=(20, 200),  # Set size range for markers
    palette="viridis",  # Use a visually appealing color palette
    alpha=0.7,  # Add transparency for better visibility
)
plt.title("Impact of Discount on Sales", fontsize=16, fontweight='bold')  # Enhanced title
plt.xlabel("Average Discount", fontsize=14)  # Increased label font size
plt.ylabel("Total Sales", fontsize=14)  # Increased label font size
plt.grid(True, linestyle='--', alpha=0.7)  # Lighter grid for better readability
sns.despine()  # Remove top and right spines for a cleaner look
plt.tight_layout()  # Adjust layout for better spacing
plt.show()

"""## (good product)تحليل المنتجات ذات أعلى مبيعات وأقل خصم"""

import pandas as pd

# تجميع البيانات لكل منتج
# Use 'PRODUCT KEY' instead of 'Product ID' for grouping as it's the primary key for products now
product_analysis = orders.groupby("PRODUCT KEY").agg({
    "Sales": "sum",      # إجمالي المبيعات لكل منتج
    "Discount": "mean"   # متوسط الخصم لكل منتج
}).reset_index()

# دمج البيانات مع جدول products_table للحصول على Category و Sub-Category
product_analysis = pd.merge(product_analysis, products_table[['PRODUCT KEY', 'Category', 'Sub-Category']], on='PRODUCT KEY', how='left') # Assuming 'products_table' is available

# ترتيب المنتجات حسب أعلى مبيعات وأقل خصم
best_products = product_analysis.sort_values(by=["Sales", "Discount"], ascending=[False, True])

# عرض أفضل 10 منتجات تحقق مبيعات عالية بخصم منخفض مع Category و Sub-Category
best_products.head(10)

"""## (good) تحليل المنتجات التي تحقق أعلى ربحية مع أقل خصم"""

#بعض المنتجات قد تحقق مبيعات جيدة ولكن بأرباح منخفضة بسبب الخصومات الكبيرة.

profit_analysis = orders.groupby("PRODUCT KEY").agg({ # Changed "Product_ID" to "PRODUCT KEY"
    "Sales": "sum",
    "Profit": "sum",
    "Discount": "mean"
}).reset_index()

# ترتيب المنتجات حسب أعلى ربح وأقل خصم
best_profit_products = profit_analysis.sort_values(by=["Profit", "Discount"], ascending=[False, True])

# عرض أفضل 10 منتجات
best_profit_products.head(10)

"""## **تحليل المنتجات ذات المبيعات الجيدة ولكن بأرباح منخفضة بسبب الخصومات**إعادة تسعير"""

# حساب إجمالي المبيعات والأرباح ومتوسط الخصم لكل منتج
# Change 'Product_ID' to 'PRODUCT KEY' as it's the primary key for products now
low_profit_analysis = orders.groupby("PRODUCT KEY").agg({
    "Sales": "sum",
    "Profit": "sum",
    "Discount": "mean"
}).reset_index()

# تصنيف المنتجات ذات المبيعات العالية والأرباح المنخفضة
low_profit_analysis = low_profit_analysis[(low_profit_analysis["Sales"] > low_profit_analysis["Sales"].median()) &
                                          (low_profit_analysis["Profit"] < low_profit_analysis["Profit"].median())]

# ترتيب المنتجات حسب أعلى مبيعات وأقل أرباح
low_profit_analysis = low_profit_analysis.sort_values(by=["Sales", "Profit"], ascending=[False, True])

# عرض أفضل 10 منتجات في هذه الفئة
low_profit_analysis.head(10)

import seaborn as sns
import matplotlib.pyplot as plt

# Set the style for the plot
sns.set_theme(style="whitegrid")  # Use a clean whitegrid style

plt.figure(figsize=(12, 8))  # Increase figure size for better readability

# Create the scatter plot with enhancements
scatter = sns.scatterplot(
    data=low_profit_analysis,
    x="Discount",
    y="Profit",
    size="Sales",
    hue="Sales",
    palette="coolwarm",  # Use a diverging color palette for better contrast
    sizes=(20, 300),  # Adjust size range for better visibility
    alpha=0.7,  # Add transparency for better readability when points overlap
    edgecolor="black",  # Add edge color to the markers
    linewidth=1.2,  # Adjust linewidth for better visibility
)

# Customize plot elements
plt.title(
    "Effect of Discount on Profit",  # English title
    fontsize=18,  # Adjust font size for emphasis
    fontweight='bold',  # Make the title bold
)
plt.xlabel(
    "Average Discount",  # English x-axis label
    fontsize=14,  # Adjust font size for readability
)
plt.ylabel(
    "Total Profit",  # English y-axis label
    fontsize=14,  # Adjust font size for readability
)
plt.xticks(fontsize=12)  # Adjust x-axis tick font size
plt.yticks(fontsize=12)  # Adjust y-axis tick font size

# Get the legend handles and labels directly from the Axes object
handles, labels = scatter.get_legend_handles_labels()

# Add a legend for size and color
legend_size = plt.legend(
    handles,
    labels,
    title="Sales",
    loc="upper right",
    bbox_to_anchor=(1.15, 1),  # Adjust legend position outside the plot
    fontsize=12,
    title_fontsize=14,
)

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

"""## 📊 تحليل أداء المنتجات عبر الزمن لتحديد المواسم القوية والضعيفة"""

product_sales_trend = orders.groupby(["PRODUCT KEY", "Year", "Month","Quarter"])["Sales"].sum().reset_index()
print(product_sales_trend.head())

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Assuming you have already calculated top_months and low_months

# Calculate average sales for each month
monthly_avg_sales = product_sales_trend.groupby('Month')['Sales'].mean().reset_index()

# Define a threshold for low sales (you may adjust this based on your data)
low_sales_threshold = monthly_avg_sales['Sales'].quantile(0.25)  # Using 25th percentile as threshold

# Identify low-sale months
low_months = monthly_avg_sales[monthly_avg_sales['Sales'] < low_sales_threshold]

# Calculate total sales for each month
monthly_sales = product_sales_trend.groupby('Month')['Sales'].sum().reset_index()

# Create a column to mark low-sale months
monthly_sales['Low_Month'] = False
low_months_list = low_months['Month'].tolist()  # Get list of low-sale months
monthly_sales.loc[monthly_sales['Month'].isin(low_months_list), 'Low_Month'] = True  # Mark low-sale months

# Plot the bar chart with highlighting for low-sale months
plt.figure(figsize=(10, 6))
ax = sns.barplot(data=monthly_sales, x='Month', y='Sales',
                 palette=['red' if is_low_month else 'steelblue' for is_low_month in monthly_sales['Low_Month']])
plt.title('Monthly Sales')
plt.xlabel('Month')
plt.ylabel('Total Sales')

# Add sales values above each bar using ax.text
for p in ax.patches:
    ax.annotate(f'{p.get_height():.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                 ha='center', va='center', xytext=(0, 10), textcoords='offset points', fontsize=10)

plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# 1. دمج جدول المنتجات مع جدول الطلبات للحصول على اسم المنتج
merged_data = pd.merge(orders_table, products_table, on="PRODUCT KEY", how="left")

# 2. حساب إجمالي المبيعات لكل منتج شهريًا
# Check if 'Product Name' column exists in merged_data
if 'Product Name_x' in merged_data.columns:
    product_sales_trend = merged_data.groupby(['Month', 'Product Name_x'])['Sales'].sum().reset_index()
else:
    # If not found, print the available columns for debugging
    print(f"Available columns in merged_data: {merged_data.columns}")
    # Optionally, try a different column name if you suspect a mismatch
    # For example, if the column is named 'product_name', replace 'Product Name' with 'product_name'
    # product_sales_trend = merged_data.groupby(['Month', 'product_name'])['Sales'].sum().reset_index()

# 3. تحديد المنتجات ذات الأداء المنخفض (تعديل العتبة حسب الحاجة)
low_sales_threshold = product_sales_trend.groupby('Product Name_x')['Sales'].sum().quantile(0.25)
low_sales_products = product_sales_trend.groupby('Product Name_x')['Sales'].sum().reset_index()
low_sales_products = low_sales_products[low_sales_products['Sales'] < low_sales_threshold]

# 4. تصفية بيانات اتجاه المبيعات للمنتجات ذات الأداء المنخفض فقط
low_perf_trend = product_sales_trend[product_sales_trend['Product Name_x'].isin(low_sales_products['Product Name_x'])]

# 5. رسم بيانات اتجاه المبيعات مع تحسينات للعرض
plt.figure(figsize=(14, 8))
sns.lineplot(data=low_perf_trend, x='Month', y='Sales', hue='Product Name_x', marker='o', palette='viridis')  # استخدام لوحة ألوان أفضل

plt.title('Sales Trend for Low Performing Products', fontsize=16, fontweight='bold')  # عنوان أكبر وأكثر وضوحًا
plt.xlabel('Month', fontsize=12)  # تسمية المحور X
plt.ylabel('Total Sales', fontsize=12)  # تسمية المحور Y
plt.xticks(range(1, 13), ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])  # أسماء الشهور
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)  # تحسين حجم الخط في الأسطورة
plt.grid(True, linestyle='--', alpha=0.7)  # شبكة أكثر نعومة
sns.despine()  # إزالة الحدود العلوية واليمنى للمخطط

plt.tight_layout()  # ضبط المسافات تلقائيًا
plt.show()

"""## **📊 تحليل الفئات (Category & Sub-Category) وتأثيرها على المبيع**ات"""

import pandas as pd

# Assuming you have already loaded orders_table and products_table

# Merge orders_table with products_table using 'PRODUCT KEY'
orders_with_category = pd.merge(orders_table, products_table[['PRODUCT KEY', 'Category']], on='PRODUCT KEY', how='left')

# Now, orders_with_category will have a new column 'Category'
# You can use this DataFrame for your analysis

# Example: Group by 'Category' and calculate total sales
category_sales = orders_with_category.groupby('Category')['Sales'].sum().reset_index()
category_sales = category_sales.sort_values(by='Sales', ascending=False)
print(category_sales)

# Assuming 'orders_table' and 'products_table' are your DataFrames
# If you saved them as CSV files, load them like this:
# orders_table = pd.read_csv("orders_table.csv")
# products_table = pd.read_csv("products_table.csv")

# Merge orders_table with products_table to get the Sub-Category
merged_data = orders_table.merge(products_table, on='PRODUCT KEY', how='left')  # Changed 'Product Key' to 'PRODUCT KEY'

# Calculate total sales for each Sub-Category
sub_category_sales = merged_data.groupby('Sub-Category')['Sales'].sum().reset_index()

# Now you can sort the data
sub_category_sales = sub_category_sales.sort_values(by='Sales', ascending=False)

# Display the top 10 sub-categories
print(sub_category_sales.head(10))

import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd

# Assuming you have already loaded orders_table and products_table

# Calculate total sales per product and month
product_sales_trend = orders_table.groupby(['PRODUCT KEY', 'Month'])['Sales'].sum().reset_index()

# Merge product_sales_trend with products_table to get the 'Category' column
product_sales_trend = pd.merge(product_sales_trend, products_table[['PRODUCT KEY', 'Category']], on='PRODUCT KEY', how='left')

# Now, product_sales_trend will have the 'Category' column

# Set the style for the plot
sns.set_theme(style="whitegrid")

# Create the line plot with enhancements
plt.figure(figsize=(14, 7))  # Adjust figure size for better proportions
ax = sns.lineplot(
    data=product_sales_trend,
    x="Month",
    y="Sales",
    hue="Category",
    palette="viridis",  # Use a visually appealing color palette
    linewidth=2.5,  # Increase line width for better visibility
    marker='o',  # Add markers to the lines
    markersize=8,  # Adjust marker size
    style="Category",  # Use different line styles for each category
    dashes=True,  # Add dashes to the lines
)

# Customize plot elements
plt.title(
    'Sales Trend per Category Over Time',
    fontsize=16,
    fontweight='bold',
)
plt.xlabel(
    'Month',
    fontsize=14,
)
plt.ylabel(
    'Total Sales',
    fontsize=14,
)

# Set x-axis ticks to represent month names
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']  # Month names
plt.xticks(range(1, 13), months, rotation=45, ha='right', fontsize=12)

# Customize legend
plt.legend(title="Category", fontsize=12, title_fontsize=12)

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

merged_data = orders_table.merge(products_table, on='PRODUCT KEY', how='left')  # Changed 'Product Key' to 'PRODUCT KEY'
#file['PRODUCT KEY'] = file['Product ID'].astype(str) + "_" + file['Product Name'] # This line seems unnecessary as merged_data is already created
#merged_data = orders_table.merge(products_table, on='PRODUCT KEY', how='left') # This line is redundant

# Calculate total sales for each Sub-Category
sub_category_sales = merged_data.groupby('Sub-Category')['Sales'].sum().reset_index() # Define sub_category_sales here

# ترتيب البيانات تنازليًا حسب المبيعات
sub_category_sales = sub_category_sales.sort_values(by='Sales', ascending=False)

# عرض النتائج
print(sub_category_sales.head(10))  # عرض أعلى 10 فئات فرعية من حيث المبيعات

plt.figure(figsize=(12,6))
sns.barplot(data=sub_category_sales, x='Sub-Category', y='Sales', palette='coolwarm')
plt.title('Total Sales by Sub-Category')
plt.xlabel('Sub-Category')
plt.ylabel('Total Sales')
plt.xticks(rotation=90)
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# 1. Merge orders_table with products_table to get 'Category'
orders_with_category = pd.merge(orders_table, products_table[['PRODUCT KEY', 'Category']], on='PRODUCT KEY', how='left')

# 2. Group by 'order_date' and 'Category', and calculate total sales
category_time_sales = orders_with_category.groupby(['order_date', 'Category'])['Sales'].sum().reset_index()

# 3. Create the line plot with enhancements
plt.figure(figsize=(16, 8))  # Adjust figure size for better readability
sns.set_theme(style="whitegrid")  # Use a clean whitegrid style
ax = sns.lineplot(
    data=category_time_sales,
    x='order_date',
    y='Sales',
    hue='Category',
    palette="viridis",  # Use a visually appealing color palette
    linewidth=2.5,  # Increase line width for better visibility
    marker='o',  # Add markers to the lines
    markersize=8,  # Adjust marker size
    style="Category",  # Use different line styles for each category
    dashes=True,  # Add dashes to the lines
)

# Customize plot elements
plt.title(
    'Sales Trend by Category Over Time',
    fontsize=18,
    fontweight='bold',
)
plt.xlabel(
    'Date',
    fontsize=14,
)
plt.ylabel(
    'Total Sales',
    fontsize=14,
)

# Customize x-axis ticks for better readability
plt.xticks(rotation=45, ha='right', fontsize=12)

# Customize legend
plt.legend(title="Category", fontsize=12, title_fontsize=12)

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Merge orders_table with products_table to get 'Sub-Category'
orders_table = pd.merge(orders_table, products_table[['PRODUCT KEY', 'Sub-Category']], on='PRODUCT KEY', how='left')

# Calculate total sales and average discount for each sub-category
sub_category_discount = orders_table.groupby('Sub-Category').agg({'Sales': 'sum', 'Discount': 'mean'}).reset_index()

# Create the scatter plot with enhancements
plt.figure(figsize=(14, 8))  # Increased figure size
sns.set_theme(style="whitegrid")  # Use white background with grid

sns.scatterplot(
    data=sub_category_discount,
    x='Discount',
    y='Sales',
    hue='Sub-Category',
    size='Sales',
    sizes=(50, 500),  # Adjusted point sizes
    palette='viridis',  # Gradient color scheme
    edgecolor='black',  # Added black borders to points
    linewidth=1,  # Adjusted border thickness
    alpha=0.8  # Adjusted point transparency
)

# Enhancements to the plot's formatting
plt.title('Impact of Discount on Sales for Sub-Categories', fontsize=18, fontweight='bold')  # More prominent title
plt.xlabel('Average Discount', fontsize=14)  # X-axis label
plt.ylabel('Total Sales', fontsize=14)  # Y-axis label
plt.xticks(fontsize=12)  # Adjusted x-axis tick font size
plt.yticks(fontsize=12)  # Adjusted y-axis tick font size
plt.legend(fontsize=12, title='Sub-Category', title_fontsize=12)  # Enhanced legend
plt.grid(True, linestyle='--', alpha=0.7)  # Added grid with adjusted transparency

plt.tight_layout()  # Adjusted layout for better spacing
plt.show()

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Merge orders_table with products_table to get 'Category'
orders_with_category = pd.merge(orders_table, products_table[['PRODUCT KEY', 'Category']], on='PRODUCT KEY', how='left')

# Calculate total sales and average discount for each category
category_discount = orders_with_category.groupby('Category').agg({'Sales': 'sum', 'Discount': 'mean'}).reset_index()

# Create the scatter plot with enhancements
plt.figure(figsize=(14, 8))  # Increased figure size
sns.set_theme(style="whitegrid")  # Use white background with grid

sns.scatterplot(
    data=category_discount,
    x='Discount',
    y='Sales',
    hue='Category',
    size='Sales',
    sizes=(50, 500),  # Adjusted point sizes
    palette='viridis',  # Gradient color scheme
    edgecolor='black',  # Added black borders to points
    linewidth=1,  # Adjusted border thickness
    alpha=0.8  # Adjusted point transparency
)

# Enhancements to the plot's formatting
plt.title('Impact of Discount on Sales for Categories', fontsize=18, fontweight='bold')  # More prominent title
plt.xlabel('Average Discount', fontsize=14)  # X-axis label
plt.ylabel('Total Sales', fontsize=14)  # Y-axis label
plt.xticks(fontsize=12)  # Adjusted x-axis tick font size
plt.yticks(fontsize=12)  # Adjusted y-axis tick font size
plt.legend(fontsize=12, title='Category', title_fontsize=12)  # Enhanced legend
plt.grid(True, linestyle='--', alpha=0.7)  # Added grid with adjusted transparency

plt.tight_layout()  # Adjusted layout for better spacing
plt.show()

"""## **Location Analysis**"""

# Assuming 'file' contains your data
unique_cities = file['City'].nunique()
unique_states = file['State'].nunique()

# Print the results
print(f"Number of unique cities: {unique_cities}")
print(f"Number of unique states: {unique_states}")

# Assuming 'file' or 'location_table' contains your data
location_counts = file.groupby(['City', 'State'])['Identity_Key'].count().reset_index()
location_counts.rename(columns={'Identity_Key': 'Count'}, inplace=True)

# Print the results in a formatted way
print("Location Counts (City, State):")
for index, row in location_counts.iterrows():
    print(f"- {row['City']}, {row['State']}: {row['Count']}")

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd # Make sure pandas is imported

# Assuming 'orders_table' contains your data and has a 'Region' column
# If not, replace 'orders_table' with the correct DataFrame name
region_sales = orders_table.groupby('Region')['Sales'].sum().reset_index()  # Calculate region_sales

# Now you can continue with your plotting code:
# ضبط حجم المخطط
plt.figure(figsize=(12, 6))

# إنشاء مخطط شريطي مع ألوان متدرجة
ax = sns.barplot(data=region_sales, x='Region', y='Sales', palette='coolwarm', edgecolor='black')

# إضافة القيم فوق كل عمود
for p in ax.patches:
    ax.annotate(f'{p.get_height():,.0f}', (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='bottom', fontsize=11, fontweight='bold', color='black')

# تحسين التنسيقات
plt.title('Total Sales by Region', fontsize=14, fontweight='bold')
plt.xlabel('Region', fontsize=12)
plt.ylabel('Total Sales', fontsize=12)
plt.xticks(rotation=45, ha='right', fontsize=11)
plt.grid(axis='y', linestyle='--', alpha=0.7)

# عرض المخطط
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd  # Import pandas for data manipulation

# Merge orders_table with location_table to get 'City' column
# Assuming orders_table and location_table are defined elsewhere
orders_table = pd.merge(orders_table, location_table[['LOCATION KEY', 'City']], on='LOCATION KEY', how='left', suffixes=('', '_location'))  # Add suffixes to avoid duplicate column names
# Calculate total sales per city and select the top 20
# Assuming orders_table is defined and has 'City' and 'Sales' columns
city_sales = orders_table.groupby('City')['Sales'].sum().reset_index()
top_20_cities = city_sales.sort_values(by='Sales', ascending=False).head(20)


# Create a bar plot for the top 20 cities by sales with enhancements
# Assuming top_20_cities is defined
plt.figure(figsize=(14, 8))  # Adjust figure size for better readability
sns.set_theme(style="whitegrid")  # Use a white background with grid for a cleaner look
palette = sns.color_palette("viridis", n_colors=20)  # Use a gradient color palette

ax = sns.barplot(
    data=top_20_cities,
    x='City',
    y='Sales',
    palette=palette,  # Apply the color palette
    edgecolor=".2",  # Add edge color to the bars
    linewidth=1.5,  # Adjust linewidth for better visibility
)

# Customize plot elements
plt.title(
    'Top 20 Cities by Total Sales',
    fontsize=18,  # Increase title font size
    fontweight='bold',  # Make title bold
)
plt.xlabel(
    'City',
    fontsize=14,  # Increase x-axis label font size
)
plt.ylabel(
    'Total Sales',
    fontsize=14,  # Increase y-axis label font size
)
plt.xticks(rotation=45, ha='right', fontsize=12)  # Rotate x-axis labels for better readability

# Add data labels to the bars
for p in ax.patches:
    ax.annotate(
        f'{p.get_height():,.0f}',  # Format sales with thousands separator
        (p.get_x() + p.get_width() / 2., p.get_height()),
        ha='center',
        va='center',
        xytext=(0, 10),
        textcoords='offset points',
        fontsize=10,
    )

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

import pandas as pd

# دمج جدول الطلبات مع جدول المواقع بناءً على 'LOCATION KEY'
merged_data = orders_table.merge(location_table[['LOCATION KEY', 'Region']], on='LOCATION KEY', how='left')

# عرض أول 5 صفوف للتحقق
merged_data.head()

# تحويل order_date إلى datetime
merged_data['order_date'] = pd.to_datetime(merged_data['order_date'])
# تجميع المبيعات حسب التاريخ والمنطقة
region_time_sales = merged_data.groupby(['order_date', 'Region_y'])['Sales'].sum().reset_index()

# عرض أول 5 صفوف للتحقق
region_time_sales.head()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Assuming 'region_time_sales' is already defined

# If 'Region_y' is present instead of 'Region', rename it:
if 'Region_y' in region_time_sales.columns and 'Region_y' not in region_time_sales.columns:
    region_time_sales.rename(columns={'Region_y': 'Region'}, inplace=True)

# رسم مخطط يوضح اتجاه المبيعات لكل منطقة بمرور الوقت
plt.figure(figsize=(14, 8))

# Use a more visually appealing color palette
sns.lineplot(
    data=region_time_sales,
    x='order_date',
    y='Sales',
    hue='Region_y',
    marker='o',
    palette='viridis',  # Use a gradient color palette
    linewidth=2,  # Increase line width for better visibility
    markersize=8,  # Increase marker size
)

# تحسين التنسيق
plt.title('Sales Trend by Region Over Time', fontsize=16, fontweight='bold')
plt.xlabel('Date', fontsize=14)
plt.ylabel('Total Sales', fontsize=14)
plt.legend(title='Region_y', fontsize=12, title_fontsize=12)  # Enhance legend
plt.xticks(rotation=45, ha='right', fontsize=12)  # Rotate x-axis labels and adjust font size
plt.yticks(fontsize=12)  # Adjust y-axis tick font size
plt.grid(True, linestyle='--', alpha=0.7)  # Lighter grid

# Add data labels to highlight specific points (optional)
# For example, to label the last data point for each region:
# for region in region_time_sales['Region'].unique():
#     last_data_point = region_time_sales[region_time_sales['Region'] == region].iloc[-1]
#     plt.text(last_data_point['order_date'], last_data_point['Sales'], region, ha='left', va='bottom', fontsize=10)

# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# عرض المخطط
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Check if 'Region' column exists in orders_table
if 'Region' in orders_table.columns:
    print("Region column is present in orders_table")

    # Proceed with analysis and visualization
    region_sales_analysis = orders_table.groupby('Region').agg({'Sales': 'sum', 'Discount': 'mean'}).reset_index()

    plt.figure(figsize=(12, 6))
    sns.scatterplot(
        data=region_sales_analysis,
        x='Discount',
        y='Sales',
        hue='Region',
        size='Sales',
        sizes=(50, 400),
        palette="viridis",
        alpha=0.7,
    )

    for i in range(len(region_sales_analysis)):
        plt.text(
            region_sales_analysis.loc[i, 'Discount'] + 0.01,
            region_sales_analysis.loc[i, 'Sales'],
            region_sales_analysis.loc[i, 'Region'],
            fontsize=10,
            ha='left',
            va='center',
        )

    plt.title('Impact of Discount on Sales by Region', fontsize=16, fontweight='bold')
    plt.xlabel('Average Discount', fontsize=12)
    plt.ylabel('Total Sales', fontsize=12)
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.show()

else:
    print("Region column is missing in orders_table. Please add it first.")

# تحليل أفضل وأسوأ المناطق من حيث معدل النمو
# حساب إجمالي المبيعات لكل منطقة في كل سنة
merged_data['Year'] = merged_data['order_date'].dt.year # Changed 'Order Date' to 'order_date'

# Check if 'Region' column exists in merged_data
# If not, it might be named 'Region_x' or 'Region_y' due to the merge
region_column = 'Region'
if 'Region' not in merged_data.columns:
    if 'Region_x' in merged_data.columns:
        region_column = 'Region_x'
    elif 'Region_y' in merged_data.columns:
        region_column = 'Region_y'
    else:
        raise KeyError("Region column not found in merged_data")

# Use the correct region column name for grouping:
region_yearly_sales = merged_data.groupby([region_column, 'Year'])['Sales'].sum().reset_index()

# حساب معدل النمو السنوي لكل منطقة
region_yearly_sales['Sales Growth'] = region_yearly_sales.groupby(region_column)['Sales'].pct_change() * 100 # Use region_column here as well

# ترتيب المناطق بناءً على معدل النمو الأخير
growth_summary = region_yearly_sales.dropna().groupby(region_column)['Sales Growth'].last().reset_index() # Use region_column here as well
growth_summary = growth_summary.sort_values(by='Sales Growth', ascending=False)

# رسم المخطط
plt.figure(figsize=(12,6))
sns.barplot(data=growth_summary, x='Sales Growth', y=region_column, palette='coolwarm', edgecolor='black') # Use region_column here as well

# تحسين التنسيقات
plt.title('Annual Sales Growth by Region', fontsize=14, fontweight='bold')
plt.xlabel('Sales Growth (%)', fontsize=12)
plt.ylabel('Region', fontsize=12)
plt.grid(axis='x', linestyle='--', alpha=0.7)

plt.show()

import pandas as pd

# تحميل البيانات (يفترض أن الجداول لديك جاهزة)
# orders يحتوي على: Order ID, Customer ID, Order Date, Product Key
# products يحتوي على: Product Key, Product Name, Category

# تحويل تاريخ الطلبات إلى صيغة datetime
# Changed "Order Date" to "order_date" to match the column name
orders["order_date"] = pd.to_datetime(orders["order_date"])

# استخراج السنة والشهر لتجميع البيانات شهريًا
orders["Year-Month"] = orders["order_date"].dt.to_period("M")

# Function to find the correct product key column
def get_product_key_column(df):
    """Returns the name of the Product Key column ('Product Key', 'Product Key x', or 'Product Key y')."""
    # Check for all possible product key column names
    for key in ['PRODUCT KEY', 'Product Key x', 'Product Key y']:  # Added 'PRODUCT KEY'
        if key in df.columns:
            return key
    # Raise KeyError if none of the expected columns are found
    raise KeyError("Product Key column not found. Expected one of: 'PRODUCT KEY', 'Product Key x', 'Product Key y'")

import pandas as pd

# تحديد أول طلب لكل عميل
# Changed "Order Date" to "order_date" to match the column name
first_order = orders.groupby("Customer ID")["order_date"].min().reset_index()
first_order.rename(columns={"order_date": "First Purchase Date"}, inplace=True)

# دمج البيانات لتحديد العملاء الجدد والمستمرين
# Changed 'df' to 'orders' to use the correct DataFrame
customer_table = orders.merge(first_order, on="Customer ID", how="left")

# تصنيف العملاء
# Changed 'df' to 'customer_table'
customer_table["Customer Type"] = customer_table.apply(
    lambda x: "New" if x["order_date"] == x["First Purchase Date"] else "Returning", axis=1
)

import pandas as pd

# Assuming 'orders' is defined in a previous cell (ipython-input-112-e483ba4de24e)
# Assuming 'first_order' is defined in a previous cell (ipython-input-0-e483ba4de24e)

# تحديد أول طلب لكل عميل
# Changed "Order Date" to "order_date" to match the column name
first_order = orders.groupby("Customer ID")["order_date"].min().reset_index()
first_order.rename(columns={"order_date": "First Purchase Date"}, inplace=True)

# دمج البيانات لتحديد العملاء الجدد والمستمرين
# Changed 'df' to 'orders' to use the correct DataFrame
customer_table = orders.merge(first_order, on="Customer ID", how="left")

# تصنيف العملاء
# Changed 'df' to 'customer_table'
customer_table["Customer Type"] = customer_table.apply(
    lambda x: "New" if x["order_date"] == x["First Purchase Date"] else "Returning", axis=1
)

# Now calculate customer counts:
customer_counts = customer_table.groupby(["Year-Month", "Customer Type"])["Customer ID"].nunique().unstack()

# حساب النسب المئوية
customer_counts["New Customers %"] = (customer_counts["New"] / customer_counts.sum(axis=1)) * 100
customer_counts["Returning Customers %"] = (customer_counts["Returning"] / customer_counts.sum(axis=1)) * 100

# عرض النتائج
print(customer_counts)

# استخراج السنة فقط بدلاً من السنة-الشهر
customer_table["Year"] = customer_table["order_date"].dt.year  # Changed 'Order Date' to 'order_date'

# حساب العدد لكل سنة
customer_counts_yearly = customer_table.groupby(["Year", "Customer Type"])["Customer ID"].nunique().unstack()

# حساب النسب المئوية
customer_counts_yearly["New Customers %"] = (customer_counts_yearly["New"] / customer_counts_yearly.sum(axis=1)) * 100
customer_counts_yearly["Returning Customers %"] = (customer_counts_yearly["Returning"] / customer_counts_yearly.sum(axis=1)) * 100

# عرض النتائج
print(customer_counts_yearly)

import matplotlib.pyplot as plt
import seaborn as sns

# Assuming customer_counts_yearly is already calculated

# Set the style for the plot
sns.set_theme(style="whitegrid")

# Create the stacked bar chart
customer_counts_yearly[['New', 'Returning']].plot(kind='bar', stacked=True, figsize=(10, 6), color=['skyblue', 'lightcoral'])

# Customize the plot
plt.title('Customer Type Distribution Over Years', fontsize=16, fontweight='bold')
plt.xlabel('Year', fontsize=14)
plt.ylabel('Number of Customers', fontsize=14)
plt.xticks(rotation=0, ha='center', fontsize=12)  # Keep x-axis labels horizontal
plt.yticks(fontsize=12)
plt.legend(title='Customer Type', fontsize=12)

# Add data labels for better clarity
for i, v in enumerate(customer_counts_yearly.index):
    total_customers = customer_counts_yearly.loc[v, 'New'] + customer_counts_yearly.loc[v, 'Returning']
    new_percentage = customer_counts_yearly.loc[v, 'New'] / total_customers * 100
    returning_percentage = customer_counts_yearly.loc[v, 'Returning'] / total_customers * 100

    plt.text(i, customer_counts_yearly.loc[v, 'New'] / 2, f'{new_percentage:.0f}%', ha='center', va='center', color='black', fontsize=10)
    plt.text(i, customer_counts_yearly.loc[v, 'New'] + customer_counts_yearly.loc[v, 'Returning'] / 2, f'{returning_percentage:.0f}%', ha='center', va='center', color='black', fontsize=10)


# Remove top and right spines for a cleaner look
sns.despine()

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

"""## **Ship Mode Analysis**"""

# Assuming 'orders_table' or 'file' contains your data
ship_mode_counts = orders_table['Ship_Mode'].value_counts()

# Print the results in a formatted way
print("Ship Mode Counts:")
for ship_mode, count in ship_mode_counts.items():
    print(f"- {ship_mode}: {count}")

import matplotlib.pyplot as plt
import seaborn as sns

#1️⃣ تحليل نسبة استخدام كل "Ship Mode" 🚢
# حساب عدد الطلبات لكل وسيلة شحن
ship_mode_counts = merged_data['Ship_Mode'].value_counts().reset_index() # Changed 'Ship Mode' to 'Ship_Mode'
ship_mode_counts.columns = ['Ship Mode', 'Order Count'] # Changed 'Ship_Mode' to 'Ship Mode' in column name

# تحديد ألوان مميزة
colors = sns.color_palette('Set2')  # Or any other palette you like

# إبراز قطاع معين (مثال: Standard Class)
explode = [0, 0.1, 0, 0]  # Explode the second slice (Standard Class)

# رسم المخطط الدائري مع التحسينات
plt.figure(figsize=(8, 6))
plt.pie(
    ship_mode_counts['Order Count'],
    labels=ship_mode_counts['Ship Mode'],
    autopct='%1.1f%%',
    colors=colors,
    startangle=90,
    explode=explode,
    shadow=True,
    textprops={'fontsize': 12},  # Increase font size of labels
    wedgeprops={'edgecolor': 'black', 'linewidth': 1},  # Add black border to slices
)

# تحسين التنسيقات
plt.title('Distribution of Ship Mode Usage', fontsize=16, fontweight='bold')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

plt.show()

# تأثير "Ship Mode" على المبيعات
# تجميع المبيعات حسب Ship Mode
ship_mode_sales = merged_data.groupby('Ship_Mode')['Sales'].sum().reset_index()
ship_mode_sales = ship_mode_sales.sort_values(by='Sales', ascending=False)

# رسم المخطط مع تحسينات
plt.figure(figsize=(10, 6))  # حجم الرسم
sns.barplot(
    data=ship_mode_sales,
    x='Ship_Mode',
    y='Sales',
    palette='Blues_r',  # نظام ألوان احترافي
    edgecolor='black',  # حدود سوداء للخطوط
    linewidth=1.2,  # عرض خط الحدود
)

# تحسين التنسيقات
plt.title(
    'Total Sales by Ship Mode',  # عنوان أوضح
    fontsize=16,
    fontweight='bold',
)
plt.xlabel(
    'Ship Mode',
    fontsize=14,
)
plt.ylabel(
    'Total Sales',
    fontsize=14,
)

# إضافة قيم المبيعات أعلى كل خط
for index, value in enumerate(ship_mode_sales['Sales']):
    plt.text(
        index,
        value,
        f'{value:,.0f}',  # عرض القيم بفاصلات الآلاف
        ha='center',
        va='bottom',
        fontsize=12,
    )

plt.grid(axis='y', linestyle='--', alpha=0.7)  # شبكة خلفية خفيفة
sns.despine()  # إزالة الحدود العلوية واليمنى

plt.tight_layout()  # تحسين المسافات
plt.show()

# رسم مخطط يوضح العلاقة بين مدة الشحن ووسيلة الشحن مع تحسينات احترافية
plt.figure(figsize=(10, 5))  # تغيير حجم المخطط (اختياري)

# استخدام sns.boxplot مع تحسينات:
sns.boxplot(
    data=merged_data,
    x='Ship_Mode',  # تصحيح اسم العمود
    y='Shipping Duration',
    palette='coolwarm',  # نظام ألوان جذاب
    linewidth=2,  # زيادة سمك خطوط الصندوق
    fliersize=5,  # تغيير حجم النقاط الخارجية
    showmeans=True, # إظهار متوسطات القيم
    meanprops={"marker":"o",
               "markerfacecolor":"white",
               "markeredgecolor":"black",
              "markersize":"10"} # تخصيص شكل و حجم علامة المتوسط
)

# تحسين التنسيقات:
plt.title('Delivery Time by Ship Mode', fontsize=16, fontweight='bold')  # زيادة حجم الخط وجعله غامقًا
plt.xlabel('Ship Mode', fontsize=14)  # زيادة حجم الخط
plt.ylabel('Shipping Duration (Days)', fontsize=14)  # زيادة حجم الخط
plt.xticks(rotation=45, ha='right')  # تدوير تسميات المحور X وتعديل المحاذاة (اختياري)
plt.grid(axis='y', linestyle='--', alpha=0.7)  # شبكة خلفية أكثر وضوحًا

sns.despine()  # إزالة الحدود العلوية واليمنى للمخطط

plt.tight_layout()  # ضبط المسافات تلقائيًا
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Analyzing the impact of shipping mode on sales and profit

# Group data by Ship Mode and calculate total sales and profit
ship_analysis = merged_data.groupby('Ship_Mode').agg({'Sales': 'sum', 'Profit': 'sum'}).reset_index()

# Reshape data into long format for easier plotting using melt
# Corrected the column name in id_vars to 'Ship_Mode' to match the column name in 'ship_analysis'
ship_analysis_melted = ship_analysis.melt(id_vars='Ship_Mode', var_name='Metric', value_name='Value')

# Create the bar plot with enhancements
plt.figure(figsize=(10, 6))  # Larger size for better display
sns.barplot(data=ship_analysis_melted, x='Ship_Mode', y='Value', hue='Metric', palette='viridis')  # Professional color scheme

# Improve plot aesthetics
plt.title('Impact of Ship Mode on Sales & Profit', fontsize=16, fontweight='bold')  # Clear title
plt.xlabel('Ship Mode', fontsize=14)  # X-axis label
plt.ylabel('Total Value', fontsize=14)  # Y-axis label
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.legend(title='Metric', fontsize=12)  # Legend title and font size

# Add value labels above the bars
for p in plt.gca().patches:
    plt.gca().text(p.get_x() + p.get_width() / 2., p.get_height(), f'{p.get_height():,.0f}',
                 ha='center', va='bottom', fontsize=10)

plt.tight_layout()  # Adjust spacing
plt.grid(axis='y', linestyle='--', alpha=0.7)  # Add a subtle background grid
sns.despine()  # Remove top and right spines for a cleaner look

plt.show()

# تحليل تاخير التوصيل
import numpy as np

# Assuming 'Shipping Duration' is your actual column name, and you want to check if shipping took more than 3 days
merged_data['Delivery Status'] = np.where(merged_data['Shipping Duration'] <= 3, 'On-Time', 'Delayed')  # Using Shipping Duration directly

# حساب نسبة الشحنات المتأخرة والمبكرة لكل وسيلة شحن
delivery_analysis = merged_data.groupby(['Ship_Mode', 'Delivery Status']).size().unstack().fillna(0)

# حساب النسب المئوية لكل وسيلة شحن
delivery_analysis_percentage = delivery_analysis.div(delivery_analysis.sum(axis=1), axis=0) * 100

# رسم المخطط البياني
plt.figure(figsize=(10,5))
delivery_analysis_percentage.plot(kind='bar', stacked=True, colormap='coolwarm', figsize=(10,5))

# تحسين العرض
plt.title('On-time vs. Delayed Shipments by Ship Mode', fontsize=14, fontweight='bold')
plt.xlabel('Ship Mode', fontsize=12)
plt.ylabel('Percentage (%)', fontsize=12)
plt.legend(title='Delivery Status')
plt.xticks(rotation=15)

plt.show()

# تحديد العملاء الذين قاموا بأكثر من عملية شراءl -loyalty analysis
customer_orders = merged_data.groupby('Customer ID')['Order ID'].nunique().reset_index()
customer_orders.columns = ['Customer ID', 'Total Orders']

# ضم بيانات العملاء مع بيانات التوصيل
customer_data = merged_data.merge(customer_orders, on='Customer ID', how='left')

# تصنيف العملاء إلى "تعرضوا لتأخير" أو "لم يتعرضوا لتأخير"
customer_data['Delayed Shipment'] = np.where(customer_data['Delivery Status'] == 'Delayed', 1, 0)

# حساب معدل تكرار الشراء للعملاء المتأثرين بالتأخير وغير المتأثرين
loyalty_analysis = customer_data.groupby('Delayed Shipment')['Total Orders'].mean()

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Assuming you have already calculated 'loyalty_analysis'

# Create the bar plot with enhancements
plt.figure(figsize=(10, 6))  # Increased figure size for better readability
ax = sns.barplot(
    x=loyalty_analysis.index,
    y=loyalty_analysis.values,
    palette="coolwarm",  # Use a visually appealing color palette
    edgecolor=".2",  # Add edge color to the bars
    linewidth=1.5,  # Adjust linewidth for better visibility
)

# Customize plot elements
plt.title(
    "Impact of Delivery Delays on Customer Loyalty",
    fontsize=16,
    fontweight="bold",
)
plt.xlabel("Delivery Status", fontsize=14)
plt.ylabel("Average Orders per Customer", fontsize=14)
plt.xticks(ticks=[0, 1], labels=["On-Time Deliveries", "Delayed Deliveries"], fontsize=12)  # Increased font size for x-axis labels

# Add data labels to the bars
for p in ax.patches:
    ax.annotate(
        f"{p.get_height():.2f}",  # Format data label to two decimal places
        (p.get_x() + p.get_width() / 2., p.get_height()),
        ha="center",
        va="center",
        xytext=(0, 10),
        textcoords="offset points",
        fontsize=12,  # Increased font size for data labels
    )

# Remove top and right spines for a cleaner look
sns.despine()

# Add a subtle background grid
plt.grid(axis="y", linestyle="--", alpha=0.7)

# Adjust layout for better spacing
plt.tight_layout()

# Show the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np

# 1. Merge data for shipping analysis
shipping_data = pd.merge(merged_data, orders_table[['Order ID', 'Region']], on="Order ID", how="left")

# 2. Select specific columns from location_table to avoid duplicates
shipping_data = pd.merge(shipping_data, location_table[['LOCATION KEY', 'Country', 'State']], on="LOCATION KEY", how="left")  # Only merge necessary columns


# 2. Create 'Delivery Status' and 'Delayed Shipment' if they don't exist
if 'Delivery Status' not in shipping_data.columns:
    shipping_data['Delivery Status'] = np.where(shipping_data['Shipping Duration'] <= 3, 'On-Time', 'Delayed')

if 'Delayed Shipment' not in shipping_data.columns:
    shipping_data['Delayed Shipment'] = np.where(shipping_data['Delivery Status'] == 'Delayed', 1, 0)

# 3. Aggregate data by region
region_shipping = shipping_data.groupby('Region').agg(
    Total_Orders=('Order ID', 'count'),
    Avg_Delivery_Days=('Shipping Duration', 'mean'),
    Delayed_Orders=('Delayed Shipment', 'sum')
).reset_index()

# 4. Calculate delay percentage
region_shipping['Delay_Percentage'] = (region_shipping['Delayed_Orders'] / region_shipping['Total_Orders']) * 100

# 5. Visualization: Average Delivery Duration by Region
plt.figure(figsize=(12, 6))  # Increased figure size
sns.barplot(data=region_shipping, x='Region', y='Avg_Delivery_Days', palette='coolwarm')
plt.title('Average Delivery Duration by Region', fontsize=16, fontweight='bold') # Enhanced title
plt.xlabel('Region', fontsize=14)  # Increased font size
plt.ylabel('Average Delivery Time (Days)', fontsize=14)  # Increased font size
plt.xticks(rotation=45, ha='right', fontsize=12)  # Rotate x-axis labels with better alignment
plt.grid(axis='y', linestyle='--', alpha=0.7)  # Added gridlines
sns.despine()  # Removed top and right spines
plt.tight_layout()  # Adjusted spacing

# Add data labels to the bars
for p in plt.gca().patches:
    plt.gca().text(p.get_x() + p.get_width() / 2., p.get_height(), f'{p.get_height():.1f}',
                 ha='center', va='bottom', fontsize=10)  # Display values on bars

plt.show()

# 6. Visualization: Delayed Shipments Percentage by Region
plt.figure(figsize=(12, 6))  # Increased figure size
sns.barplot(data=region_shipping, x='Region', y='Delay_Percentage', palette='Reds_r')
plt.title('Delayed Shipments Percentage by Region', fontsize=16, fontweight='bold')  # Enhanced title
plt.xlabel('Region', fontsize=14)  # Increased font size
plt.ylabel('Delay Percentage (%)', fontsize=14)  # Increased font size
plt.xticks(rotation=45, ha='right', fontsize=12)  # Rotate x-axis labels with better alignment
plt.grid(axis='y', linestyle='--', alpha=0.7)  # Added gridlines
sns.despine()  # Removed top and right spines
plt.tight_layout()  # Adjusted spacing

# Add data labels to the bars
for p in plt.gca().patches:
    plt.gca().text(p.get_x() + p.get_width() / 2., p.get_height(), f'{p.get_height():.1f}%',
                 ha='center', va='bottom', fontsize=10) # Display percentages on bars

plt.show()

"""## **Forecasting **

#✅ 1️⃣ التنبؤ بالمبيعات (Sales Forecasting) باستخدام ARIMA
"""

import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt

# Assuming 'orders_table' contains your data
sales_monthly = orders_table.groupby(['Year', 'Month'])['Sales'].sum().reset_index() # Creating sales_monthly DataFrame here
sales_monthly['Year-Month'] = sales_monthly['Year'].astype(str) + '-' + sales_monthly['Month'].astype(str).str.zfill(2) # Create 'Year-Month' column


# تحويل Year-Month إلى Index زمني
sales_monthly["Year-Month"] = pd.to_datetime(sales_monthly["Year-Month"])
sales_monthly.set_index("Year-Month", inplace=True)

# بناء نموذج ARIMA
model_sales = ARIMA(sales_monthly["Sales"], order=(5,1,0))  # (p,d,q) ممكن نعدّلها لاحقًا
model_fit_sales = model_sales.fit()

# التنبؤ بـ 12 شهر قادمًا
forecast_sales = model_fit_sales.forecast(steps=12)

# رسم التنبؤات
plt.figure(figsize=(12, 6))
plt.plot(sales_monthly.index, sales_monthly["Sales"], label="Actual Sales", marker="o")
plt.plot(pd.date_range(start=sales_monthly.index[-1], periods=12, freq="M"), forecast_sales, label="Forecast", marker="o", linestyle="dashed", color="r")

plt.title("Sales Forecast for Next 12 Months")
plt.xlabel("Date")
plt.ylabel("Sales")
plt.legend()
plt.grid(True)
plt.show()

!pip install prophet # Use 'prophet' instead of 'fbprophet'
# Restart the kernel after installation.
from prophet import Prophet # Change import statement to use 'prophet' instead of 'fbprophet'
import matplotlib.pyplot as plt
import seaborn as sns

# تجهيز البيانات لـ Prophet
df_sales = sales_monthly.reset_index()
df_sales.rename(columns={"Year-Month": "ds", "Sales": "y"}, inplace=True)

# إنشاء النموذج
model = Prophet()
model.fit(df_sales)

# تحديد فترة التنبؤ (12 شهرًا قادمة)
future = model.make_future_dataframe(periods=12, freq="M")
forecast = model.predict(future)

# --- Visualization Enhancements ---
# 1. Create a figure and axes with a larger size
fig, ax = plt.subplots(figsize=(12, 6))

# 2. Plot actual and forecasted values using Seaborn for better styling
sns.lineplot(data=df_sales, x='ds', y='y', ax=ax, label='Actual Sales', marker='o', color='blue')
sns.lineplot(data=forecast, x='ds', y='yhat', ax=ax, label='Forecast', marker='o', color='red', linestyle='--')

# 3. Customize plot elements
ax.set_title('Sales Forecast for Next 12 Months', fontsize=16, fontweight='bold')
ax.set_xlabel('Date', fontsize=14)
ax.set_ylabel('Sales', fontsize=14)

# 4. Add a shaded confidence interval
ax.fill_between(forecast['ds'], forecast['yhat_lower'], forecast['yhat_upper'], color='pink', alpha=0.3, label='Confidence Interval')

# 5. Improve legend and grid
ax.legend(fontsize=12)
ax.grid(True, linestyle='--', alpha=0.7)

# 6. Remove top and right spines for a cleaner look
sns.despine()

# 7. Adjust layout for better spacing
plt.tight_layout()

# 8. Show the plot
plt.show()

"""## ✅ 2️⃣ التنبؤ بالأرباح (Profit Forecasting) بنفس الطريقة


"""

!pip install pmdarima

import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt
from pmdarima import auto_arima # Import auto_arima for automatic order selection


# Assuming 'orders_table' contains your data
profit_monthly = orders_table.groupby(['Year', 'Month'])['Profit'].sum().reset_index()
profit_monthly['Year-Month'] = profit_monthly['Year'].astype(str) + '-' + profit_monthly['Month'].astype(str).str.zfill(2)

# Convert 'Year-Month' to datetime and set as index
profit_monthly["Year-Month"] = pd.to_datetime(profit_monthly["Year-Month"])
profit_monthly.set_index("Year-Month", inplace=True)

# Automatic ARIMA Order Selection using auto_arima
# Find the best (p, d, q) values automatically
best_model_order = auto_arima(profit_monthly["Profit"], seasonal=False, stepwise=True, suppress_warnings=True).order

# Build ARIMA model for profit using the automatically selected order
model_profit = ARIMA(profit_monthly["Profit"], order=best_model_order)
model_fit_profit = model_profit.fit()

# Forecast profit for the next 12 months
forecast_profit = model_fit_profit.forecast(steps=12)

# --- Visualization Enhancements ---
plt.figure(figsize=(14, 7))  # Increased figure size for better readability
plt.plot(profit_monthly.index, profit_monthly["Profit"], label="Actual Profit", marker="o", color="blue", linewidth=2)
plt.plot(pd.date_range(start=profit_monthly.index[-1], periods=12, freq="M"), forecast_profit, label="Forecast", marker="o", linestyle="dashed", color="red", linewidth=2)

plt.title("Profit Forecast for Next 12 Months", fontsize=16, fontweight="bold")
plt.xlabel("Date", fontsize=14)
plt.ylabel("Profit", fontsize=14)

# Add a shaded confidence interval to the forecast
# Get confidence intervals for the forecast
conf_int = model_fit_profit.get_forecast(steps=12).conf_int()
lower_conf = conf_int.iloc[:, 0]
upper_conf = conf_int.iloc[:, 1]

plt.fill_between(pd.date_range(start=profit_monthly.index[-1], periods=12, freq="M"), lower_conf, upper_conf, color="pink", alpha=0.3, label="Confidence Interval")

plt.legend(fontsize=12)
plt.grid(True, linestyle="--", alpha=0.7)
sns.despine()
plt.tight_layout()
plt.show()

"""# 🔥 3️⃣ تحسين التنبؤ باستخدام Prophet


"""

!pip install prophet
from prophet import Prophet
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd


# Assuming 'orders_table' contains your data
profit_monthly = orders_table.groupby(['Year', 'Month'])['Profit'].sum().reset_index()
profit_monthly['Year-Month'] = profit_monthly['Year'].astype(str) + '-' + profit_monthly['Month'].astype(str).str.zfill(2)

# Convert 'Year-Month' to datetime and set as index
profit_monthly["Year-Month"] = pd.to_datetime(profit_monthly["Year-Month"])
profit_monthly.set_index("Year-Month", inplace=True)

# Prepare data for Prophet
df_profit = profit_monthly.reset_index()
df_profit.rename(columns={"Year-Month": "ds", "Profit": "y"}, inplace=True)

# Create and fit the Prophet model
model_profit = Prophet()
model_profit.fit(df_profit)

# Make future dataframe for forecasting
future_profit = model_profit.make_future_dataframe(periods=12, freq="M")

# Generate forecast
forecast_profit = model_profit.predict(future_profit)

# --- Visualization Enhancements ---
fig, ax = plt.subplots(figsize=(12, 6))

# Plot actual and forecasted values
sns.lineplot(data=df_profit, x='ds', y='y', ax=ax, label='Actual Profit', marker='o', color='blue')
sns.lineplot(data=forecast_profit, x='ds', y='yhat', ax=ax, label='Forecast', marker='o', color='red', linestyle='--')

# Customize plot elements
ax.set_title('Profit Forecast for Next 12 Months', fontsize=16, fontweight='bold')
ax.set_xlabel('Date', fontsize=14)
ax.set_ylabel('Profit', fontsize=14)

# Add a shaded confidence interval
ax.fill_between(forecast_profit['ds'], forecast_profit['yhat_lower'], forecast_profit['yhat_upper'], color='pink', alpha=0.3, label='Confidence Interval')

# Improve legend and grid
ax.legend(fontsize=12)
ax.grid(True, linestyle='--', alpha=0.7)

# Remove top and right spines
sns.despine()

# Adjust layout
plt.tight_layout()

# Show the plot
plt.show()

"""# 📌 تحسين التنبؤ بإضافة متغيرات إضافية (Discount, Category)

"""

!pip install prophet
!pip install pmdarima

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import mean_absolute_error

# Assuming your data is in the file "Superstore Sales Dataset.csv"
file = pd.read_csv("Superstore Sales Dataset.csv", encoding='latin-1')

# ... (Data cleaning and transformation steps from your previous code) ...

# Create the 'Year-Month' column in sales_monthly
sales_monthly['Year-Month'] = sales_monthly['Year'].astype(str) + '-' + sales_monthly['Month'].astype(str).str.zfill(2)
sales_monthly["Year-Month"] = pd.to_datetime(sales_monthly["Year-Month"])
sales_monthly.set_index("Year-Month", inplace=True)
sales_monthly.reset_index(inplace=True) # Reset index to make 'Year-Month' a regular column


# Merge 'Category' from 'products_table' into 'sales_monthly' using 'Product Key'
# Now, merge using 'Year-Month' and 'order_date' to link corresponding rows
sales_monthly = sales_monthly.merge(orders_table[['Order ID', 'Product ID','Product Name', 'order_date']], left_on='Year-Month', right_on='order_date', how='left')  # Change 'Order Date' to 'order_date'
sales_monthly['PRODUCT KEY'] = sales_monthly['Product ID'].astype(str) + "_" + sales_monthly['Product Name']
sales_monthly = sales_monthly.merge(products_table[['PRODUCT KEY', 'Category']], on='PRODUCT KEY', how='left')
sales_monthly = sales_monthly.drop(columns=['Product ID', 'Product Name','PRODUCT KEY','Order ID', 'order_date'])  # Change 'Order Date' to 'order_date'

# One-Hot Encoding for 'Category'
encoder = OneHotEncoder(sparse_output=False)  # Changed 'sparse' to 'sparse_output'
category_encoded = encoder.fit_transform(sales_monthly[["Category"]])
category_df = pd.DataFrame(category_encoded, columns=encoder.get_feature_names_out(["Category"]))

# Merge encoded categories with original data
sales_monthly = pd.concat([sales_monthly, category_df], axis=1).drop(columns=["Category"])

# Define features (X) and target (y)
X = sales_monthly.drop(columns=["Sales"])
y = sales_monthly["Sales"]

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Assuming 'sales_monthly' is the original DataFrame with 'Year-Month'

# ... (your code for merging and one-hot encoding) ...

# Convert 'Year-Month' to numerical features before splitting
# Keep the 'Year-Month' column temporarily for extracting year and month
sales_monthly['Year'] = sales_monthly['Year-Month'].dt.year  # Get year from 'Year-Month'
sales_monthly['Month'] = sales_monthly['Year-Month'].dt.month # Get month from 'Year-Month'

# Now, drop the 'Year-Month' column from sales_monthly
sales_monthly = sales_monthly.drop(columns=['Year-Month'])

# Define features (X) and target (y) after adding 'Year' and 'Month' and dropping 'Year-Month'
X = sales_monthly.drop(columns=["Sales"])
y = sales_monthly["Sales"]

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

import numpy as np

# Prepare future data (next 12 months)
last_year = sales_monthly['Year'].max()
last_month = sales_monthly[sales_monthly['Year'] == last_year]['Month'].max()
start_date = pd.to_datetime(f'{last_year}-{last_month}') + pd.DateOffset(months=1)

future_dates = pd.date_range(start=start_date, periods=12, freq="M")

# Create a DataFrame for future data with the correct columns
future_df = pd.DataFrame({'Year': future_dates.year, 'Month': future_dates.month})

# You'll need to add your logic for future discount and categories
# Example: assume discount is 0 and all categories are 0
future_df['Discount'] = 0  # Replace with your discount prediction logic
for category in category_df.columns:
    future_df[category] = 0  # Replace with your category prediction logic

# Add 'ds' column (required by Prophet) containing the future dates
future_df['ds'] = future_dates

# Ensure 'ds' column is present and contains the future dates
# This line is removed as it is redundant with the above line
# future_df['ds'] = future_dates

# Reorder columns to match the order used during training
# Ensure future_df has all columns present in X_train
for col in X_train.columns:
    if col not in future_df.columns:
        future_df[col] = 0  # Or another appropriate default value
future_df = future_df[X_train.columns]  # Ensure columns are in the same order as X_train

# ***Perform the sales forecasting***
# Assuming you have a trained RandomForestRegressor named 'rf_model'
# Replace with your actual model if different
from sklearn.ensemble import RandomForestRegressor # Import RandomForestRegressor
rf_model = RandomForestRegressor() # Initialize the model
rf_model.fit(X_train, y_train) # Fit the model to the training data
future_sales = rf_model.predict(future_df) # Make predictions on the future data


# Display results
forecast_df = pd.DataFrame({"Predicted Sales": future_sales}, index=future_dates)
print(forecast_df)

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Filter sales_monthly to include data from 2015 onwards
sales_monthly_filtered = sales_monthly[sales_monthly['Year'] >= 2015]

# Create a new 'Year-Month' column for plotting
sales_monthly_filtered['Year-Month'] = pd.to_datetime(sales_monthly_filtered['Year'].astype(str) + '-' + sales_monthly_filtered['Month'].astype(str).str.zfill(2))

# رسم المبيعات الحقيقية والتنبؤات
plt.figure(figsize=(12, 6))

# Plot actual sales using the filtered data and the new 'Year-Month' column
plt.plot(sales_monthly_filtered['Year-Month'], sales_monthly_filtered["Sales"], label="Actual Sales", marker="o", color="blue", linewidth=2)

# Plot forecasted sales using the index of forecast_df (which should be datetime)
plt.plot(forecast_df.index, forecast_df["Predicted Sales"], label="Forecasted Sales", marker="s", linestyle="dashed", color="red", linewidth=2)

# Add legend and show the plot
plt.legend()
plt.show()

import pandas as pd
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error

# ... (your existing code to prepare 'product_sales' DataFrame) ...

# 1. Prepare the data for forecasting
# Instead of 'product_sales', use 'orders_table' or 'sales_monthly'
# Assuming 'orders_table' is the DataFrame with the required columns
X = orders_table[["Year", "Month", "Discount"]]  # Features for prediction
y = orders_table["Sales"]  # Target variable

# 2. Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)  # Adjust test_size and random_state as needed

# 3. Create and train the XGBoost model
model = XGBRegressor(n_estimators=100, learning_rate=0.1)  # Adjust hyperparameters as needed
model.fit(X_train, y_train)

# 4. Make predictions on the test set
y_pred = model.predict(X_test)

# 5. Evaluate the model
mae = mean_absolute_error(y_test, y_pred)
print(f"Mean Absolute Error: {mae}")

# 6. Create future data for forecasting
# Example: Forecast for the next 12 months
# Assuming 'orders_table' is the DataFrame with the required columns
future_dates = pd.date_range(start=orders_table['order_date'].max(), periods=12, freq='MS')  # 'MS' for month start frequency
future_data = pd.DataFrame({'Year': future_dates.year, 'Month': future_dates.month, 'Discount': 0.0})  # Assume no discount for future
future_data.set_index(future_dates, inplace=True)

# Make forecasts for the future
future_predictions = model.predict(future_data)

import matplotlib.pyplot as plt
import numpy as np

# Example actual and predicted sales values
actual_sales = [100, 150, 120, 180, 140]
predicted_sales = [90, 160, 110, 170, 130]

# Calculate the absolute errors
absolute_errors = np.abs(np.array(actual_sales) - np.array(predicted_sales))

# Calculate the MAE
mae = np.mean(absolute_errors)

# Create the plot
plt.figure(figsize=(8, 6))
plt.plot(actual_sales, marker='o', label='Actual Sales', color='blue')
plt.plot(predicted_sales, marker='x', label='Predicted Sales', color='red')

# Add lines for absolute errors
for i in range(len(actual_sales)):
    plt.vlines(i, ymin=min(actual_sales[i], predicted_sales[i]), ymax=max(actual_sales[i], predicted_sales[i]),
               linestyles='dashed', colors='gray')

# Add text for MAE
plt.text(0.5, 190, f'MAE = {mae:.2f}', fontsize=12, ha='center')

plt.title('Actual vs. Predicted Sales with MAE', fontsize=14)
plt.xlabel('Data Point', fontsize=12)
plt.ylabel('Sales', fontsize=12)
plt.legend()
plt.grid(True)
plt.show()

"""# ✅ 1️⃣ التنبؤ بعدد العملاء الجدد والمستمرين

"""

import pandas as pd
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split

# 1. تحضير البيانات:
X = customer_counts_yearly.index.values.reshape(-1, 1)  # Year as independent variable
y_new = customer_counts_yearly["New Customers %"]
y_returning = customer_counts_yearly["Returning Customers %"]

# تقسيم البيانات (مثال: 80% تدريب، 20% اختبار)
X_train, X_test, y_new_train, y_new_test = train_test_split(X, y_new, test_size=0.2, shuffle=False)
X_train, X_test, y_returning_train, y_returning_test = train_test_split(X, y_returning, test_size=0.2, shuffle=False)

# 2. بناء النموذج:
model_new = XGBRegressor(n_estimators=100, learning_rate=0.1, random_state=42)
model_returning = XGBRegressor(n_estimators=100, learning_rate=0.1, random_state=42)

model_new.fit(X_train, y_new_train)
model_returning.fit(X_train, y_returning_train)

# 3. التوقع:
# إنشاء بيانات للسنوات القادمة (مثال: 5 سنوات)
future_years = np.arange(X.max() + 1, X.max() + 6).reshape(-1, 1)

# التنبؤ
forecasted_new = model_new.predict(future_years)
forecasted_returning = model_returning.predict(future_years)

# عرض النتائج
forecast_df = pd.DataFrame({
    "Year": future_years.flatten(),
    "New Customers %": forecasted_new,
    "Returning Customers %": forecasted_returning
})

print(forecast_df)

# 4. تمثيل النتائج بيانيًا:
plt.figure(figsize=(12, 6))

# رسم القيم الحقيقية
plt.plot(customer_counts_yearly.index, customer_counts_yearly["New Customers %"], label="Actual New Customers %", marker="o")
plt.plot(customer_counts_yearly.index, customer_counts_yearly["Returning Customers %"], label="Actual Returning Customers %", marker="o")

# رسم القيم المتوقعة
plt.plot(forecast_df["Year"], forecast_df["New Customers %"], label="Forecasted New Customers %", linestyle="--")
plt.plot(forecast_df["Year"], forecast_df["Returning Customers %"], label="Forecasted Returning Customers %", linestyle="--")

# تحسينات الرسم البياني
plt.title("Customer Type Forecasting")
plt.xlabel("Year")
plt.ylabel("Percentage (%)")
plt.legend()
plt.grid(True)
plt.show()

"""# 📊 2️⃣ توقع المبيعات لكل منتج (Product-Level

Forecasting) باستخدام XGBoost
:
"""

import pandas as pd
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error

# Assuming you have the 'orders_table' DataFrame ready

# Group data by product and aggregate sales
product_sales = orders_table.groupby(['Product Name', 'Year', 'Month'])['Sales'].sum().reset_index()

# Add Discount (if available at the product level, otherwise use overall average)
# If you have product-level discount data, merge it here
# Otherwise, use the average discount from orders_table:
average_discount = orders_table['Discount'].mean()
product_sales['Discount'] = average_discount

# Display the first few rows of the prepared data
product_sales.head()

# Create a dictionary to store individual models for each product
product_models = {}

# Iterate through unique products
for product in product_sales['Product Name'].unique():
    # Filter data for the current product
    product_data = product_sales[product_sales['Product Name'] == product]

    # Select features and target variable
    X = product_data[['Year', 'Month', 'Discount']]
    y = product_data['Sales']

    # Check if there are enough samples to split
    if len(X) > 1: # Check if there is more than one sample for the current product
        # Split data into training and testing sets if enough samples
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)  # Time-based split
    else:
        # Handle cases with insufficient data, for example:
        print(f"Skipping product '{product}' due to insufficient data for splitting.") # Print a message, or
        X_train, X_test, y_train, y_test = X, None, y, None  # Assign all data to training and set testing to None, or
        # Consider alternative approaches like using the entire dataset for training and skipping testing
        continue # Skip to the next product

    # Store the training and testing data for this product
    product_models[product] = {
        'X_train': X_train,
        'X_test': X_test,
        'y_train': y_train,
        'y_test': y_test
    }

# Iterate through product models and train XGBoost
for product, data in product_models.items():
    # Create and train the XGBoost model
    model = XGBRegressor(n_estimators=100, learning_rate=0.1)  # Adjust hyperparameters
    model.fit(data['X_train'], data['y_train'])

    # Store the trained model
    product_models[product]['model'] = model

# Forecast future sales for each product
future_predictions = {}

for product, data in product_models.items():
    # Get the maximum order date for the current product from the original 'orders_table'
    max_order_date = orders_table[orders_table['Product Name'] == product]['order_date'].max()

    # Create future data (example: next 12 months)
    future_dates = pd.date_range(start=max_order_date, periods=12, freq='MS')
    future_data = pd.DataFrame({'Year': future_dates.year, 'Month': future_dates.month, 'Discount': average_discount})

    # Make predictions
    future_sales = data['model'].predict(future_data)

    # Store predictions
    future_predictions[product] = future_sales

# Display or further process the future_predictions dictionary

# Create a DataFrame from the predictions
all_predictions = pd.DataFrame(future_predictions)

# Add the future dates as index
all_predictions.index = future_dates

# Display the DataFrame
print(all_predictions)

import matplotlib.pyplot as plt

# Select top 5 products for plotting
top_products = all_predictions.sum().nlargest(5).index

# Plot only the selected products
fig, ax = plt.subplots(figsize=(12, 6))  # Create a figure and axes object with a specific size

for product in top_products:
    ax.plot(all_predictions.index, all_predictions[product], label=product, linewidth=2)  # Plot each product with a thicker line

# Customize the plot
ax.set_title('Future Sales Forecast for Top 5 Products', fontsize=16)  # Increase title font size
ax.set_xlabel('Date', fontsize=12)  # Increase x-axis label font size
ax.set_ylabel('Sales', fontsize=12)  # Increase y-axis label font size
ax.legend(fontsize=10)  # Adjust legend font size
ax.grid(True, linestyle='--', alpha=0.7)  # Add a grid for better readability
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better visibility

plt.tight_layout()  # Adjust layout to prevent overlapping elements
plt.show()

import matplotlib.pyplot as plt

# Select bottom 5 products for plotting
bottom_products = all_predictions.sum().nsmallest(5).index # Changed nlargest to nsmallest

# Plot only the selected products
fig, ax = plt.subplots(figsize=(12, 6))  # Create a figure and axes object with a specific size

for product in bottom_products:
    ax.plot(all_predictions.index, all_predictions[product], label=product, linewidth=2)  # Plot each product with a thicker line

# Customize the plot
ax.set_title('Future Sales Forecast for Bottom 5 Products', fontsize=16)  # Changed title
ax.set_xlabel('Date', fontsize=12)  # Increase x-axis label font size
ax.set_ylabel('Sales', fontsize=12)  # Increase y-axis label font size
ax.legend(fontsize=10)  # Adjust legend font size
ax.grid(True, linestyle='--', alpha=0.7)  # Add a grid for better readability
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better visibility

plt.tight_layout()  # Adjust layout to prevent overlapping elements
plt.show()

# Create separate plots for each product
for product in all_predictions.columns:
    plt.figure()  # Create a new figure for each product
    plt.plot(all_predictions.index, all_predictions[product], label=product)
    plt.title(f'Future Sales Forecast for {product}')
    plt.xlabel('Date')
    plt.ylabel('Sales')
    plt.legend()
    plt.show()

"""## **(Region Forecasting)  🚀**"""

import pandas as pd

orders_table = pd.read_csv('orders_table.csv')
location_table = pd.read_csv('location_table.csv')

merged_data = pd.merge(orders_table, location_table, on='LOCATION KEY', how='left')

# Check if 'Region' is present in merged_data
if 'Region' not in merged_data.columns:
    # If not present, try getting it from orders_table or location_table
    if 'Region' in orders_table.columns:
        merged_data['Region'] = orders_table['Region']
    elif 'Region' in location_table.columns:
        merged_data = pd.merge(merged_data, location_table[['LOCATION KEY', 'Region']], on='LOCATION KEY', how='left')
    else:
        raise KeyError("The 'Region' column is not found in either orders_table or location_table.")

# Now you can proceed with feature selection
X = merged_data[['Region', 'State', 'order_date']]
y = merged_data['Sales']

X['order_date'] = pd.to_datetime(X['order_date']).astype(int) / 10**9

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

from sklearn.linear_model import LinearRegression # أو أي نموذج تنبؤ آخر
model = LinearRegression()

modeling_data = orders_table[['LOCATION KEY', 'Region', 'order_date', 'Sales']]

# Check if 'Region' is present in merged_data
if 'Region' not in modeling_data.columns:
    # If not present, try getting it from orders_table or location_table
    if 'Region' in orders_table.columns:
        modeling_data['Region'] = orders_table['Region']
    elif 'Region' in location_table.columns:
        modeling_data = pd.merge(modeling_data, location_table[['LOCATION KEY', 'Region']], on='LOCATION KEY', how='left')
    else:
        raise KeyError("The 'Region' column is not found in either orders_table or location_table.")

# Make sure location_table is defined before using it
# Assuming you have saved it as a CSV file earlier
import pandas as pd  # Import pandas if not already imported
location_table = pd.read_csv('location_table.csv')

# Get the 'State' column from the location_table using a merge
modeling_data = pd.merge(modeling_data, location_table[['LOCATION KEY', 'State']], on='LOCATION KEY', how='left')


# Now you can proceed with feature selection, including 'State'
X = modeling_data[['Region', 'State', 'order_date']]
y = modeling_data['Sales']

# Convert 'order_date' to numerical representation for the model
X['order_date'] = pd.to_datetime(X['order_date']).astype(int) / 10**9

# One-hot encoding for categorical features
X = pd.get_dummies(X, columns=['Region', 'State'], drop_first=True)

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create and train the model
model = LinearRegression()
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Evaluate the model (example using R-squared)
from sklearn.metrics import r2_score
r2 = r2_score(y_test, y_pred)
print(f"R-squared: {r2}")

# Now you can use the trained model to make forecasts on new data
# Prepare the new data in the same format as X_test (including one-hot encoding)
# ...
# new_data_predictions = model.predict(new_data)

# ... (previous code for loading data, preparing data, training the model, and making predictions) ...

import matplotlib.pyplot as plt # Import the matplotlib library for plotting
import seaborn as sns # Import seaborn for enhanced visualizations

# Visualization
# 1. Create a DataFrame for plotting
plot_data = pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})
plot_data.reset_index(drop=True, inplace=True)  # Reset index for plotting

# 2. Plot Actual vs Predicted values
plt.figure(figsize=(12, 6))
sns.lineplot(data=plot_data, x=plot_data.index, y='Actual', label='Actual')
sns.lineplot(data=plot_data, x=plot_data.index, y='Predicted', label='Predicted')
plt.title('Actual vs Predicted Sales')
plt.xlabel('Data Point')
plt.ylabel('Sales')
plt.legend()
plt.show()

# 3. (Optional) Plot against original data for context
# First, get the original 'order_date' and 'LOCATION KEY' for the test set
original_data = modeling_data.loc[y_test.index, ['order_date', 'LOCATION KEY']]  # Get both columns
plot_data['order_date'] = original_data['order_date'].values
plot_data['LOCATION KEY'] = original_data['LOCATION KEY'].values  # Add LOCATION KEY column


# Then, plot against 'order_date'
plt.figure(figsize=(12, 6))
sns.lineplot(data=plot_data, x='order_date', y='Actual', label='Actual')
sns.lineplot(data=plot_data, x='order_date', y='Predicted', label='Predicted')
plt.title('Actual vs Predicted Sales Over Time')
plt.xlabel('Order Date')
plt.ylabel('Sales')
plt.legend()
plt.show()

# 4. (Optional) Display forecasted values as a table
print("Forecasted Values:")
print(plot_data[['order_date', 'LOCATION KEY', 'Predicted']])  # Include LOCATION KEY in the output

# Download as Excel
plot_data[['order_date', 'LOCATION KEY', 'Predicted']].to_excel('forecasted_sales.xlsx', index=False)
from google.colab import files
files.download('forecasted_sales.xlsx')

print("Excel file downloaded!")

!pip install statsmodels

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error

# Assuming you have already loaded orders_table

# 1. Group by Region and Year and sum Sales
region_yearly_sales = orders_table.groupby(['Region', 'Year'])['Sales'].sum().reset_index()

# 2. Create a forecasting function
def forecast_region_sales(region_data, region_name):
    # Prepare data for ARIMA model
    sales_data = region_data.set_index('Year')['Sales']

    # Fit ARIMA model (you might need to tune p, d, q parameters)
    model = ARIMA(sales_data, order=(5, 1, 0))  # Example order, adjust as needed
    model_fit = model.fit()

    # Forecast for the next year (e.g., 2018 if your data ends in 2017)
    forecast = model_fit.predict(start=sales_data.index[-1] + 1, end=sales_data.index[-1] + 1)

    # Print the forecast
    print(f"Forecasted Sales for {region_name} in {sales_data.index[-1] + 1}: {forecast.iloc[0]:.2f}")

    return forecast.iloc[0]

# 3. Loop through each region and forecast
forecasts = {}
for region in region_yearly_sales['Region'].unique():
    region_data = region_yearly_sales[region_yearly_sales['Region'] == region]
    forecast = forecast_region_sales(region_data, region)
    forecasts[region] = forecast

# Calculate total forecasted sales per region
forecasted_sales_by_region = pd.DataFrame(list(forecasts.items()), columns=['Region', 'Forecasted Sales'])

# Sort by Forecasted Sales in descending order
forecasted_sales_by_region = forecasted_sales_by_region.sort_values(by=['Forecasted Sales'], ascending=False)

# Get the top N regions (e.g., top 5)
top_n_regions = forecasted_sales_by_region.head(5)  # Change 5 to the desired number of top regions

# Create the bar chart
plt.figure(figsize=(10, 6))
plt.bar(top_n_regions['Region'], top_n_regions['Forecasted Sales'], color='skyblue')
plt.title('Top Regions with Highest Potential Sales')
plt.xlabel('Region')
plt.ylabel('Forecasted Sales')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

!pip install statsmodels

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.holtwinters import ExponentialSmoothing
import numpy as np

# Assuming you have already loaded orders_table

# 1. Group by City and Year and sum Sales
city_yearly_sales = orders_table.groupby(['City', 'Year'])['Sales'].sum().reset_index()

# 2. Create a forecasting function using Exponential Smoothing
def forecast_city_sales(city_data, city_name):
    # Prepare data for Exponential Smoothing model
    sales_data = city_data.set_index('Year')['Sales']

    # Try-except block to handle any potential errors
    try:
        # Fit Exponential Smoothing model (you might need to tune parameters)
        model = ExponentialSmoothing(sales_data, trend='add', seasonal='add', seasonal_periods=1).fit()

        # Forecast for the next year (e.g., 2018 if your data ends in 2017)
        forecast = model.predict(start=sales_data.index[-1] + 1, end=sales_data.index[-1] + 1)

    except Exception as e:  # Catch any exception
        print(f"Warning: Error for city {city_name}: {e}. Using last year's sales as forecast.")
        forecast = sales_data.iloc[-1]  # Use last year's sales as a simple fallback

    # Print the forecast
    forecasted_value = forecast.iloc[0] if isinstance(forecast, pd.Series) else forecast
    print(f"Forecasted Sales for {city_name} in {sales_data.index[-1] + 1}: {forecasted_value:.2f}") # Corrected print statement

    return forecasted_value

# 3. Loop through each city and forecast
city_forecasts = {}
for city in city_yearly_sales['City'].unique():
    city_data = city_yearly_sales[city_yearly_sales['City'] == city]
    forecast = forecast_city_sales(city_data, city)
    city_forecasts[city] = forecast


# Calculate total forecasted sales per city
forecasted_sales_by_city = pd.DataFrame(list(city_forecasts.items()), columns=['City', 'Forecasted Sales'])

# Sort by Forecasted Sales in descending order
forecasted_sales_by_city = forecasted_sales_by_city.sort_values(by=['Forecasted Sales'], ascending=False)

# Get the top N cities (e.g., top 10)
top_n_cities = forecasted_sales_by_city.head(10)  # Change 10 to the desired number of top cities

# Create the bar chart
plt.figure(figsize=(12, 6))  # Adjust figure size if needed
plt.bar(top_n_cities['City'], top_n_cities['Forecasted Sales'], color='skyblue')
plt.title('Top Cities with Highest Potential Sales')
plt.xlabel('City')
plt.ylabel('Forecasted Sales')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.tight_layout()
plt.show()
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.holtwinters import ExponentialSmoothing
import numpy as np

# Assuming you have already loaded orders_table

# 1. Group by City and Year and sum Sales
city_yearly_sales = orders_table.groupby(['City', 'Year'])['Sales'].sum().reset_index()

# 2. Create a forecasting function using Exponential Smoothing
def forecast_city_sales(city_data, city_name):
    # Prepare data for Exponential Smoothing model
    sales_data = city_data.set_index('Year')['Sales']

    # Try-except block to handle any potential errors
    try:
        # Fit Exponential Smoothing model (you might need to tune parameters)
        model = ExponentialSmoothing(sales_data, trend='add', seasonal='add', seasonal_periods=1).fit()

        # Forecast for the next year (e.g., 2018 if your data ends in 2017)
        forecast = model.predict(start=sales_data.index[-1] + 1, end=sales_data.index[-1] + 1)

    except Exception as e:  # Catch any exception
        print(f"Warning: Error for city {city_name}: {e}. Using last year's sales as forecast.")
        forecast = sales_data.iloc[-1]  # Use last year's sales as a simple fallback

    # Print the forecast
    forecasted_value = forecast.iloc[0] if isinstance(forecast, pd.Series) else forecast
    print(f"Forecasted Sales for {city_name} in {sales_data.index[-1] + 1}: {forecasted_value:.2f}") # Corrected print statement

    return forecasted_value

# 3. Loop through each city and forecast
city_forecasts = {}
for city in city_yearly_sales['City'].unique():
    city_data = city_yearly_sales[city_yearly_sales['City'] == city]
    forecast = forecast_city_sales(city_data, city)
    city_forecasts[city] = forecast


# Calculate total forecasted sales per city
forecasted_sales_by_city = pd.DataFrame(list(city_forecasts.items()), columns=['City', 'Forecasted Sales'])

# Sort by Forecasted Sales in descending order
forecasted_sales_by_city = forecasted_sales_by_city.sort_values(by=['Forecasted Sales'], ascending=False)

# Get the top N cities (e.g., top 10)
top_n_cities = forecasted_sales_by_city.head(10)  # Change 10 to the desired number of top cities

# Create the bar chart
plt.figure(figsize=(12, 6))  # Adjust figure size if needed
plt.bar(top_n_cities['City'], top_n_cities['Forecasted Sales'], color='skyblue')
plt.title('Top Cities with Highest Potential Sales')
plt.xlabel('City')
plt.ylabel('Forecasted Sales')
plt.xticks(rotation=45, ha='right')  # Rotate x-axis labels for better readability
plt.tight_layout()
plt.show()

!pip install statsmodels

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.holtwinters import ExponentialSmoothing
import numpy as np

# Assuming you have already loaded the orders_table

# 1. Group by City and Year and sum Sales
city_yearly_sales = orders_table.groupby(['City', 'Year'])['Sales'].sum().reset_index()

# 2. Create a forecasting function using Exponential Smoothing
def forecast_city_sales(city_data, city_name):
    # Prepare data for Exponential Smoothing model
    sales_data = city_data.set_index('Year')['Sales']

    # Try-except block to handle any potential errors
    try:
        # Fit Exponential Smoothing model (you might need to tune parameters)
        model = ExponentialSmoothing(sales_data, trend='add', seasonal='add', seasonal_periods=1).fit()

        # Forecast for the next year (e.g., 2018 if your data ends in 2017)
        forecast = model.predict(start=sales_data.index[-1] + 1, end=sales_data.index[-1] + 1)

    except Exception as e:  # Catch any exception
        print(f"Warning: Error for city {city_name}: {e}. Using last year's sales as forecast.")
        forecast = sales_data.iloc[-1]  # Use last year's sales as a simple fallback

    # Print the forecast
    forecasted_value = forecast.iloc[0] if isinstance(forecast, pd.Series) else forecast
    print(f"Forecasted Sales for {city_name} in {sales_data.index[-1] + 1}: {forecasted_value:.2f}") # Corrected print statement

    return forecasted_value

# 3. Loop through each city and forecast
city_forecasts = {}
for city in city_yearly_sales['City'].unique():
    city_data = city_yearly_sales[city_yearly_sales['City'] == city]
    forecast = forecast_city_sales(city_data, city)
    city_forecasts[city] = forecast

# 4. Calculate total forecasted sales per city
forecasted_sales_by_city = pd.DataFrame(list(city_forecasts.items()), columns=['City', 'Forecasted Sales'])

# 5. Sort by Forecasted Sales in ASCENDING order to get the lowest first
forecasted_sales_by_city = forecasted_sales_by_city.sort_values(by=['Forecasted Sales'], ascending=True)

# 6. Get the bottom N cities (e.g., bottom 10)
bottom_n_cities = forecasted_sales_by_city.head(10)

# 7. Create the bar chart
plt.figure(figsize=(12, 6))
plt.bar(bottom_n_cities['City'], bottom_n_cities['Forecasted Sales'], color='skyblue')
plt.title('Bottom 10 Cities with Lowest Potential Sales')
plt.xlabel('City')
plt.ylabel('Forecasted Sales')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

# 1. Prepare Data
historical_data = orders_table.groupby(['order_date', 'Region'])['Order ID'].nunique().reset_index()  # Group by region
historical_data.rename(columns={'Order ID': 'Actual Orders'}, inplace=True)

# 2. Feature Engineering
historical_data['Year'] = historical_data['order_date'].dt.year
historical_data['Month'] = historical_data['order_date'].dt.month
historical_data['Day'] = historical_data['order_date'].dt.day

# 3. Model Training and Prediction for Each Region
regions = historical_data['Region'].unique()
forecasting_dfs = []

for region in regions:
    # Filter data for the current region
    region_data = historical_data[historical_data['Region'] == region]

    # Train-Test Split
    X = region_data[['Year', 'Month', 'Day']]
    y = region_data['Actual Orders']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Model Training
    model = LinearRegression()
    model.fit(X_train, y_train)

    # Future Prediction
    start_date = '2019-01-01'
    end_date = '2020-12-31'
    future_dates = pd.date_range(start=start_date, end=end_date, freq='D')
    future_df = pd.DataFrame({'order_date': future_dates})
    future_df['Year'] = future_df['order_date'].dt.year
    future_df['Month'] = future_df['order_date'].dt.month
    future_df['Day'] = future_df['order_date'].dt.day
    future_predictions = model.predict(future_df[['Year', 'Month', 'Day']])

    # Store forecasting data for the current region
    forecasting_df = pd.DataFrame({"Predicted Orders": future_predictions, 'Region': region}, index=future_dates)
    forecasting_dfs.append(forecasting_df)

# 4. Combine and Visualize
combined_forecasting_df = pd.concat(forecasting_dfs)

plt.figure(figsize=(12, 6))
for region in regions:
    region_forecasts = combined_forecasting_df[combined_forecasting_df['Region'] == region]
    plt.plot(region_forecasts.index, region_forecasts["Predicted Orders"], label=f"Predicted Orders ({region})", marker="o")

plt.title("Forecasted Orders by Region (2019-2020)")
plt.xlabel("Date")
plt.ylabel("Number of Orders")
plt.legend()
plt.grid(True)
plt.show()

"""## ***Ship Mode Forecasting ***"""

import pandas as pd

# تحويل تاريخ الطلب إلى تنسيق زمني
orders_table["order_date"] = pd.to_datetime(orders_table["order_date"])

# استخراج السنة والشهر
orders_table["Year"] = orders_table["order_date"].dt.year
orders_table["Month"] = orders_table["order_date"].dt.month

# تجميع عدد الطلبات لكل طريقة شحن شهريًا
# Changed "Order ID" to "Identity_Key" for unique order count
ship_orders = orders_table.groupby(["Year", "Month", "Ship_Mode"])["Identity_Key"].nunique().reset_index()

# تحويل السنة والشهر إلى Year-Month كفهرس زمني
ship_orders["Year-Month"] = pd.to_datetime(ship_orders[["Year", "Month"]].astype(str).agg('-'.join, axis=1))
ship_orders.set_index("Year-Month", inplace=True)

# تغيير اسم العمود ليسهل التعامل معه
# Changed "Order ID" to "Identity_Key" in rename
ship_orders.rename(columns={"Identity_Key": "Total Orders"}, inplace=True)

# تحويل "Ship Mode" إلى متغير عددي باستخدام One-Hot Encoding
ship_orders = pd.get_dummies(ship_orders, columns=["Ship_Mode"], drop_first=True)

# عرض البيانات بعد التحضير
display(ship_orders)

from sklearn.model_selection import train_test_split

# تحديد الميزات والمتغير المستهدف
features = ["Year", "Month"] + [col for col in ship_orders.columns if "Ship_Mode" in col]
target = "Total Orders"

# تقسيم البيانات إلى تدريب واختبار
X_train, X_test, y_train, y_test = train_test_split(
    ship_orders[features], ship_orders[target], test_size=0.2, random_state=42
)

from xgboost import XGBRegressor

# إنشاء النموذج
model = XGBRegressor(n_estimators=100, learning_rate=0.1, random_state=42)

# تدريب النموذج
model.fit(X_train, y_train)

from sklearn.metrics import mean_absolute_error

# التنبؤ بعدد الطلبات
y_pred = model.predict(X_test)

# حساب Mean Absolute Error (MAE)
mae = mean_absolute_error(y_test, y_pred)
print(f"Mean Absolute Error (MAE): {mae:.2f}")

import matplotlib.pyplot as plt

# إنشاء DataFrame لتسهيل الرسم
comparison_df = pd.DataFrame({"Actual Orders": y_test, "Predicted Orders": y_pred}, index=X_test.index)

# رسم عدد الطلبات الفعلية مقابل التوقعات
plt.figure(figsize=(10, 5))
plt.plot(comparison_df.index, comparison_df["Actual Orders"], label="Actual Orders", marker="o", linestyle="-", color="blue")
plt.plot(comparison_df.index, comparison_df["Predicted Orders"], label="Predicted Orders", marker="x", linestyle="--", color="red")

plt.title(f"Actual vs. Predicted Orders by Ship Mode (MAE = {mae:.2f})")
plt.xlabel("Date")
plt.ylabel("Number of Orders")
plt.legend()
plt.grid(True)
plt.show()

# Set start and end dates for forecasting
start_date = '2019-01-01'
end_date = '2020-12-31'

# Create a date range for forecasting
future_dates = pd.date_range(start=start_date, end=end_date, freq='D')  # Assuming daily frequency

# Create a DataFrame for forecasting
future_df = pd.DataFrame({'order_date': future_dates})
# Add other features if needed by your model (e.g., ship mode)

# Set start and end dates for forecasting
start_date = '2019-01-01'
end_date = '2020-12-31'

# Create a date range for forecasting
future_dates = pd.date_range(start=start_date, end=end_date, freq='D')  # Assuming daily frequency

# Create a DataFrame for forecasting with 'order_date' as a column
future_df = pd.DataFrame({'order_date': future_dates})
# Add other features if needed by your model (e.g., ship mode)


# Apply data transformations (if any) to future_df

# Extract features from 'order_date' similar to how you did for training data
future_df['Year'] = future_df['order_date'].dt.year
future_df['Month'] = future_df['order_date'].dt.month
# Add other features if needed (e.g., day of week, quarter)

# Assume 'Ship_Mode' is a categorical feature in your original dataset
# You need to create dummy variables for 'Ship_Mode' in future_df as well
# and ensure they have the same names as in the training data:
# Instead of assigning a single value, create a column with all possible 'Ship_Mode' values
future_df['Ship_Mode'] = 'Standard Class'  # Initialize with the most frequent value or an appropriate distribution
# If you have information about the distribution of Ship Modes in the future period, you can use it here

# Create dummy variables for 'Ship_Mode', ensuring all categories from training data are included
future_df = pd.get_dummies(future_df, columns=['Ship_Mode'], prefix=['Ship_Mode'],
                           # Add dummy_na=False to prevent creating a column for NaN values if any
                           dummy_na=False)

# Get missing columns (dummy variables not present in future_df)
missing_cols = set(features) - set(future_df.columns)

# Add missing columns to future_df and initialize them with 0
for col in missing_cols:
    future_df[col] = 0

# Reorder columns to match the order in 'features'
future_df = future_df[features]

# Make predictions using your trained model (replace 'model' with your actual model)
future_predictions = model.predict(future_df)

# Apply data transformations (if any) to future_df

# Make predictions using your trained model (replace 'model' with your actual model)
future_predictions = model.predict(future_df)

forecasting_df = pd.DataFrame({"Predicted Orders": future_predictions}, index=future_dates)

import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

# 1. Prepare Data
# Assuming 'orders_table' is your DataFrame
# Select relevant columns and aggregate daily order counts
historical_data = orders_table.groupby('order_date')['Order ID'].nunique().reset_index()
historical_data.rename(columns={'Order ID': 'Actual Orders'}, inplace=True)


# 2. Feature Engineering
historical_data['Year'] = historical_data['order_date'].dt.year
historical_data['Month'] = historical_data['order_date'].dt.month
historical_data['Day'] = historical_data['order_date'].dt.day
# Add other features if needed (e.g., day of week, quarter)

# 3. Train-Test Split
X = historical_data[['Year', 'Month', 'Day']]  # Features for prediction
y = historical_data['Actual Orders']  # Target variable
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Split data


# 4. Model Selection and Training
model = LinearRegression()
model.fit(X_train, y_train)  # Train the model


# 5. Prediction
# Predict on the test set
y_pred = model.predict(X_test)

# Predict for future dates
start_date = '2019-01-01'
end_date = '2020-12-31'
future_dates = pd.date_range(start=start_date, end=end_date, freq='D')
future_df = pd.DataFrame({'order_date': future_dates})
future_df['Year'] = future_df['order_date'].dt.year
future_df['Month'] = future_df['order_date'].dt.month
future_df['Day'] = future_df['order_date'].dt.day
future_predictions = model.predict(future_df[['Year', 'Month', 'Day']]) # Predict using the trained model


# 6. Evaluation and Visualization
# ... (Add code for evaluation metrics if needed)

# Visualization: Combine historical and forecasted data
forecasting_df = pd.DataFrame({"Predicted Orders": future_predictions}, index=future_dates)
combined_df = pd.concat([historical_data.set_index('order_date')['Actual Orders'], forecasting_df])

plt.figure(figsize=(12, 6))
plt.plot(combined_df.index, combined_df["Actual Orders"], label="Actual Orders (Historical)", marker="o", color="blue")
plt.plot(forecasting_df.index, forecasting_df["Predicted Orders"], label="Predicted Orders (2019-2020)", marker="x", color="red")
plt.title("Historical and Forecasted Orders")
plt.xlabel("Date")
plt.ylabel("Number of Orders")
plt.legend()
plt.grid(True)
plt.show()

import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

# 1. Prepare Data
historical_data = orders_table.groupby(['order_date', 'Ship_Mode'])['Order ID'].nunique().reset_index()
historical_data.rename(columns={'Order ID': 'Actual Orders'}, inplace=True)

# 2. Feature Engineering
historical_data['Year'] = historical_data['order_date'].dt.year
historical_data['Month'] = historical_data['order_date'].dt.month
historical_data['Day'] = historical_data['order_date'].dt.day

# 3. Model Training and Prediction for Each Ship Mode
ship_modes = historical_data['Ship_Mode'].unique()
forecasting_dfs = []  # To store forecasting DataFrames for each ship mode

for ship_mode in ship_modes:
    # Filter data for the current ship mode
    ship_mode_data = historical_data[historical_data['Ship_Mode'] == ship_mode]

    # Train-Test Split
    X = ship_mode_data[['Year', 'Month', 'Day']]
    y = ship_mode_data['Actual Orders']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Model Training
    model = LinearRegression()
    model.fit(X_train, y_train)

    # Future Prediction
    start_date = '2019-01-01'
    end_date = '2020-12-31'
    future_dates = pd.date_range(start=start_date, end=end_date, freq='D')
    future_df = pd.DataFrame({'order_date': future_dates})
    future_df['Year'] = future_df['order_date'].dt.year
    future_df['Month'] = future_df['order_date'].dt.month
    future_df['Day'] = future_df['order_date'].dt.day
    future_predictions = model.predict(future_df[['Year', 'Month', 'Day']])

    # Store forecasting data for the current ship mode
    forecasting_df = pd.DataFrame({"Predicted Orders": future_predictions, 'Ship_Mode': ship_mode}, index=future_dates)
    forecasting_dfs.append(forecasting_df)

# 4. Combine and Visualize
combined_forecasting_df = pd.concat(forecasting_dfs)

plt.figure(figsize=(12, 6))
for ship_mode in ship_modes:
    ship_mode_forecasts = combined_forecasting_df[combined_forecasting_df['Ship_Mode'] == ship_mode]
    plt.plot(ship_mode_forecasts.index, ship_mode_forecasts["Predicted Orders"], label=f"Predicted Orders ({ship_mode})", marker="o")

plt.title("Forecasted Orders by Ship Mode (2019-2020)")
plt.xlabel("Date")
plt.ylabel("Number of Orders")
plt.legend()
plt.grid(True)
plt.show()

# استيراد المكتبات
import pandas as pd

# دمج جدول الطلبات مع المنتجات باستخدام PRODUCT KEY
merged_df = orders_table.merge(products_table[["PRODUCT KEY", "Category"]], on="PRODUCT KEY", how="left")

# التحقق من البيانات بعد الدمج
print(merged_df.head())

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import numpy as np

# اختيار المتغيرات المهمة
features = ["Region", "Quantity", "Discount", "Category"]
target = "Ship Mode"
# Replace the problematic line with the corrected column name:
merged_df.dropna(subset=[target.replace("Ship Mode", "Ship_Mode")] + features, inplace=True) # Changed "Ship Mode" to "Ship_Mode" in the subset

# Replace the problematic line with the corrected column name:
merged_df["Ship Mode Encoded"] = encoder.fit_transform(merged_df[target.replace("Ship Mode", "Ship_Mode")])
# Changed "Ship Mode" to "Ship_Mode" in the subset
merged_df["Region Encoded"] = encoder.fit_transform(merged_df["Region"])
merged_df["Category Encoded"] = encoder.fit_transform(merged_df["Category"])

# اختيار البيانات النهائية للنموذج
X = merged_df[["Region Encoded", "Quantity", "Discount", "Category Encoded"]]
y = merged_df["Ship Mode Encoded"]

# تقسيم البيانات إلى تدريب واختبار
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# طباعة أول 5 صفوف للتأكد من صحة البيانات
print(X_train.head())

from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score

# إنشاء نموذج XGBoost
model = XGBClassifier(n_estimators=100, learning_rate=0.1, max_depth=5, random_state=42)

# تدريب النموذج
model.fit(X_train, y_train)

# التنبؤ على بيانات الاختبار
y_pred = model.predict(X_test)

# حساب دقة النموذج
accuracy = accuracy_score(y_test, y_pred)
print(f"📊 دقة النموذج: {accuracy * 100:.2f}%")

import pandas as pd
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

# 1. Prepare Data
historical_data = orders_table.groupby(['order_date', 'Ship_Mode'])['Order ID'].nunique().reset_index()
historical_data.rename(columns={'Order ID': 'Actual Orders'}, inplace=True)

# 2. Feature Engineering
historical_data['Year'] = historical_data['order_date'].dt.year
historical_data['Month'] = historical_data['order_date'].dt.month
historical_data['Day'] = historical_data['order_date'].dt.day
historical_data['DayOfWeek'] = historical_data['order_date'].dt.dayofweek  # Add Day of Week

# 3. Model Training and Prediction for Each Ship Mode
ship_modes = historical_data['Ship_Mode'].unique()
forecasting_dfs = []

for ship_mode in ship_modes:
    ship_mode_data = historical_data[historical_data['Ship_Mode'] == ship_mode]
    X = ship_mode_data[['Year', 'Month', 'Day', 'DayOfWeek']]
    y = ship_mode_data['Actual Orders']
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Model Training (Using XGBRegressor)
    model = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
    model.fit(X_train, y_train)

    # Future Prediction
    start_date = '2019-01-01'
    end_date = '2020-12-31'
    future_dates = pd.date_range(start=start_date, end=end_date, freq='D')
    future_df = pd.DataFrame({'order_date': future_dates})
    future_df['Year'] = future_df['order_date'].dt.year
    future_df['Month'] = future_df['order_date'].dt.month
    future_df['Day'] = future_df['order_date'].dt.day
    future_df['DayOfWeek'] = future_df['order_date'].dt.dayofweek
    future_predictions = model.predict(future_df[['Year', 'Month', 'Day', 'DayOfWeek']])

    forecasting_df = pd.DataFrame({"Predicted Orders": future_predictions, 'Ship_Mode': ship_mode}, index=future_dates)
    forecasting_dfs.append(forecasting_df)

# 4. Combine and Visualize
combined_forecasting_df = pd.concat(forecasting_dfs)

plt.figure(figsize=(12, 6))
for ship_mode in ship_modes:
    ship_mode_forecasts = combined_forecasting_df[combined_forecasting_df['Ship_Mode'] == ship_mode]
    plt.plot(ship_mode_forecasts.index, ship_mode_forecasts["Predicted Orders"], label=f"Predicted Orders ({ship_mode})", marker="o")

plt.title("Forecasted Orders by Ship Mode (2019-2020)")
plt.xlabel("Date")
plt.ylabel("Number of Orders")
plt.legend()
plt.grid(True)
plt.tight_layout()  # Adjust layout for better spacing
plt.show()

import pandas as pd
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

# 1. Prepare Data
historical_data = orders_table.groupby(['order_date', 'Ship_Mode'])['Shipping Duration'].mean().reset_index()  # Changed target to 'Shipping Duration' and used mean
historical_data.rename(columns={'Shipping Duration': 'Actual Shipping Duration'}, inplace=True)  # Renamed column

# 2. Feature Engineering (same as before)
historical_data['Year'] = historical_data['order_date'].dt.year
historical_data['Month'] = historical_data['order_date'].dt.month
historical_data['Day'] = historical_data['order_date'].dt.day
historical_data['DayOfWeek'] = historical_data['order_date'].dt.dayofweek

# 3. Model Training and Prediction for Each Ship Mode
ship_modes = historical_data['Ship_Mode'].unique()
forecasting_dfs = []

for ship_mode in ship_modes:
    ship_mode_data = historical_data[historical_data['Ship_Mode'] == ship_mode]
    X = ship_mode_data[['Year', 'Month', 'Day', 'DayOfWeek']]
    y = ship_mode_data['Actual Shipping Duration']  # Changed target variable
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Model Training (Using XGBRegressor)
    model = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
    model.fit(X_train, y_train)

    # Future Prediction (same as before)
    start_date = '2019-01-01'
    end_date = '2020-12-31'
    future_dates = pd.date_range(start=start_date, end=end_date, freq='D')
    future_df = pd.DataFrame({'order_date': future_dates})
    future_df['Year'] = future_df['order_date'].dt.year
    future_df['Month'] = future_df['order_date'].dt.month
    future_df['Day'] = future_df['order_date'].dt.day
    future_df['DayOfWeek'] = future_df['order_date'].dt.dayofweek
    future_predictions = model.predict(future_df[['Year', 'Month', 'Day', 'DayOfWeek']])

    forecasting_df = pd.DataFrame({"Predicted Shipping Duration": future_predictions, 'Ship_Mode': ship_mode}, index=future_dates)  # Changed column name
    forecasting_dfs.append(forecasting_df)

# 4. Combine and Visualize
combined_forecasting_df = pd.concat(forecasting_dfs)

plt.figure(figsize=(12, 6))
for ship_mode in ship_modes:
    ship_mode_forecasts = combined_forecasting_df[combined_forecasting_df['Ship_Mode'] == ship_mode]
    plt.plot(ship_mode_forecasts.index, ship_mode_forecasts["Predicted Shipping Duration"], label=f"Predicted Shipping Duration ({ship_mode})", marker="o")  # Changed column name

plt.title("Forecasted Shipping Duration by Ship Mode (2019-2020)")  # Changed title
plt.xlabel("Date")
plt.ylabel("Shipping Duration (Days)")  # Changed y-axis label
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
